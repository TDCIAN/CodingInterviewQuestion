# CodingInterviewQuestion


## Chapter 01. 프로그래밍 기초
### 1.1 변수(Variables)
- 컴퓨터 공학에서도 변수와 데이터를 유지하기 위해 같은 기능을 하는 무엇인가가 필요합니다.


### 1.2 자료형(Data Types)
- 프로그래밍 언어에서 자료형은 미리 특징지어진 값들을 가지는 데이터의 집합입니다.
- 예를 들면, integer(정수), floating point unit number(부동소수점 수), character(문자), string(문자열) 등이 있습니다.
- 컴퓨터의 메모리는 모두 0 또는 1로 채워집니다. 우리가 어떤 문제를 풀어야 하고 이를 0과 1로 코드화 한다는 것은 매우 어려운 일일 것입니다.
- 이를 돕기 위해 프로그래밍 언어와 해당 언어의 컴파일러는 자료형을 제공합니다.
- 기본적으로 자료형에는 다음 두 가지 유형이 있습니다.
  - 시스템 정의 자료형(원시 자료형: Primitive data types)
    - 시스템에 의해 정의된 자료형이 원시 자료형입니다.
    - 많은 프로그래밍 언어들이 제공하는 원시 자료형으로는 int, float, char, double, boolean 등이 있습니다.
    - 같은 원시 자료형이라 할 지라도 서로 다른 언어에서 서로 다른 크기를 가질 수 있습니다.
    - 가질 수 있는 크기에 따라 가질 수 있는 값의 영역도 다릅니다.

  - 사용자 정의 자료형(User defined data types)
    - 시스템 정의 자료형들이 충분하지 않을 수 있으므로 대부분의 프로그래밍 언어들이 '사용자 정의 자료형'이라 부르는 자신들만의 자료형을 선언할 수 있도록 하고 있습니다.
    - 좋은 예가 C/C++의 구조체와 Java의 클래스입니다.


### 1.3 자료 구조(Data Structure)
- 자료 구조는 컴퓨터 내에서 유용하게 사용되도록 데이터를 저장하고 구조화하는 특정한 방법을 말합니다.
- 즉, 자료 구조는 데이터를 저장하고 구조화하는 특별한 형태입니다.
- 자료 구조는 구성요소들을 어떻게 구조화하였는가에 따라 두 가지 유형으로 분류됩니다.
- 선형 자료 구조(Linear data structures)
  - 선형 자료 구조의 구성 요소들은 순차적으로 접근되지만, 모든 요소들이 반드시 순차적으로 저장되지는 않습니다(Linked Lists)
  - 예: 연결 리스트, 스택, 큐
- 비선형 자료 구조(Non-linear data structures)
  - 자료 구조의 구성 요소들이 비순차적인 순서로 저장되고 접근됩니다.
  - 예: 트리, 그래프


### 1.4 추상 자료형(Abstract Data Types - ADTs)
- 일반적으로 자료 구조와 연산을 결합하여 추상 자료형(ADTs)이라고 부릅니다.
- 추상 자료형은 데이터 선언 부분과 연산자 선언 두 부분으로 구성됩니다.
- 일반적으로 사용되는 추상 자료형은 연결 리스트, 스택, 큐, 우선 순위 큐, 이진 트리, 딕셔너리, 분리 집합(Union과 Find), 해시 테이블, 그래프 등이 있습니다.
- 예를 들어 스택은 자료 구조에 데이터를 저장할 때 LIFO(Last-In-First-Out) 메커니즘을 사용합니다.
- 추상 자료형을 정의하면서 구현의 세부 정보에 대해서는 신경쓰지 않습니다. 이는 우리가 필요할 때만 구체화됩니다.
- 여러 추상 자료형들은 각자의 특징에 맞는 용도를 가지고 있으며, 몇몇 추상 자료형은 특정 업무에 고도로 전문화되어 있습니다.


### 1.5 메모리와 변수(Memory and Variables)
- 메모리는 바이트의 배열처럼 다룰 수 있으며, 각각의 위치는 주소로 식별됩니다.
- 보통 0번 주소는 유효한 메모리 주소가 아닙니다.
- 모든 바이트를 가리키는 주소는 integer라는 것을 이해하는 게 중요합니다.
- 어떤 위치를 읽거나 쓰기 위해 CPU는 메모리 제어기(memory controller)에 그 위치를 전달하여 접근합니다.
- 변수를 생성할 때(예를 들어 C에서 int X), 컴파일러는 연속된 메모리 블록을 할당하고 이 크기는 변수의 크기에 달려 있습니다.
- 컴파일러는 또한 변수 이름 X와 할당된 첫 번째 바이트의 주소를 연결짓는 내부적인 태그를 유지합니다(흔히 symbol table이라 부릅니다).
- Size of a Variables
  - Sizeof 연산자는 변수의 크기(변수가 얼마나 많은 메모리를 차지하고 있는가)를 알아내는데 사용됩니다. 예를 들어 어떤 컴퓨터에서 Sizeof(X)가 4를 반환하였다면 integer는 메모리에서 4개의 연속된 byte가 필요하다는 것입니다. 또 X의 주소가 2000이라고 한다면 실제 X에 의해서 사용되는 메모리 주소는 2000, 2001, 2002 그리고 2003입니다.
- Address of a Variables
  - C언어에서 참조 연산자(address-of: &)를 사용하여 변수의 주소를 얻을 수 있습니다. 아래는 변수 X의 주소를 찍는 코드입니다. 일반적으로 주소 값이 클 경우 간단하고 쉽게 이해하도록 16진수로 출력됩니다.


### 1.6 포인터(Pointers)
- 포인터는 다른 변수의 주소를 보관할 수 있는 변수입니다.
- 포인터의 선언(Declare of Pointers)
  - 포인터를 선언하기 위해서는 포인터가 가리킬 변수의 자료형을 명시해야 합니다.
  - 즉, 주소를 저장하고자 하는 변수에 대한 자료형이 필요합니다.
  - 포인터 선언의 예시
```
int *ptr1;
float *ptr2;
unsigned int *ptr3;
char *ptr4; void *ptr5;

=> ptr1은 int형 변수를 가리킬 수 있는 포인터이고 
ptr2는 float형을, 
ptr3은 unsigned int형을,
ptr4는 char형을 가리킬 수 있는 포인터입니다.
끝으로 ptr5는 형을 지정하지 않아 무엇이든지 가리킬 수 있는 포인터입니다. 이러한 포인터를 void형 포인트라고 부르는데 void형 포인터는 몇 가지 제약이 있습니다.
```
- 포인터의 사용(Pointers Usages)
  - 포인터는 주소를 담습니다. 즉, 변수의 주소를 할당할 수 있습니다.
```
int X = 10;
int *ptr = &X;
- 코드에서 X라는 이름의 정수형(int) 변수를 선언하고 10으로 값을 초기화합니다. 그리고 정수형 포인터 ptr을 생성하고 X의 주소 값을 할당합니다.
- 이를 "X를 가리키는 포인터 ptr을 만들다"라고 합니다.
- 포인터로 할 수 있는 일반적인 연산은 포인터가 가리키는 메모리 주소에 있는 값을 획득하는 "간접지정(indirection)"입니다.
- 간접지정 연산자는 '*' 기호로 표시됩니다.
- 포인터를 선언할 때 사용하는 기호와 같으나 둘을 혼동해서는 안됩니다.
```
  - ptr이 가리키는 메모리 상의 값에 접근하려고 할 때 '*ptr'과 같이 사용합니다. 다음 코드는 포인터의 간접 지정을 보여줍니다.
```
int X = 10;
int *ptr = &X;
printf("X의 값: %d\n", X);
printf("ptr이 가리키는 주소: %p\n", ptr);
printf("주소에 있는 값: %d\n", *ptr);
*ptr = 25;
printf("X가 가진 값: %d\n", X);
- 전과 동일하게 변수 X(10이 출력)와 포인터 ptr을 선언하고 X와 ptr을 출력합니다.
- ptr이 가진 값은 변수 X의 주소 값이며 다음 줄에서는 포인터 ptr이 가리키는 주소에 들어있는 값을 출력합니다(마찬가지로 10이 출력)
- 끝으로 포인터 ptr이 가리키는 주소에 들어있는 값을 25로 변경하면 변수 X의 값이 변경되어 출력되는 것을 확인할 수 있는데, 이는 포인터 ptr이 변수 X의 주소 값을 가지고 있으며 ptr이 가리키는 주소에 든 값을 변경하면 변수 X의 값이 변경되기 때문입니다.
- 모든 형을 가리킬 수 있는 void 포인터의 한 가지 제약은 간접 참조를 할 수 없다는 것인데, 이는 각기 다른 자료형이 차지하는 메모리의 크기가 서로 다르기 때문입니다.
- 예를 들어 32비트 컴퓨터에서 int형은 4바이트를, short 형은 2바이트를 차지하는데, 컴파일러는 가리키는 주소에서 전체 값을 읽어 들이기 위해 얼마나 많은 바이트를 읽어야 할지 알아야 하지만 void 포인터는 그렇게 할 수 없기 때문입니다.
```

- 포인터 연산(Pointer Manipulation)
  - 포인터의 또 다른 유용함은 산술 연산을 적용할 수 있다는 것입니다. 어차피 포인터가 정수형이라고 했으니 당연한 것이 아닐까 하겠지만, 포인터의 산술 연산에는 미묘한 차이가 있습니다.
```
char *cptr = (char*)2;
printf("cptr before: %p", cptr);
cptr++;
printf("cptr after: %p", cptr);
- cptr라는 포인터를 선언하고 2라는 주소를 할당한 후 첫 번째 출력(주소 2가 출력)을 하였습니다.
- 그리고 포인터를 증가시킨 후 다시 출력(3이 출력)하였습니다.
- 정확히 기대하던 대로 하나의 값이 증가하여 출력 되었습니다.

int *iptr = (int*)2;
printf("iptr before: %p", iptr);
iptr++;
printf("iptr after: %p \n", iptr);
- iptr before는 2, after는 6으로 출력됩니다.
- 포인터를 1 증가시켰을 뿐인데 이런 일이 발생하는 것은 변수의 sizeof 값에 있습니다.
- 컴퓨터에서 int의 길이는 4바이트 입니다.
- 즉, 주소 2에 정수형(int) 변수가 위치하고 있다면 이 변수는 메모리 주소 2, 3, 4, 5를 점유하게 되며, 다음 정수형에 접근하기 위해 6, 7, 8, 9 주소를 찾게 됩니다.
- 따라서 우리가 정수형 포인터에 1을 증가시키는 연산을 하게 되면 정수형 변수의 다음 위치 값을 되돌려 주기 때문에 이렇게 되는 것입니다.
- void 포인터의 또 다른 제약은 컴파일러가 얼마나 이동해야 다음 값이 있는지 알 수 없기 때문에 포인터에 산술연산을 할 수 없다는 것입니다.
- 그래서 void 포인터는 사용하기 전에 나중에 반환해야 하는 특정 포인터 유형의 주소를 보관하기 위해서만 사용할 수 있습니다.
```

- 배열과 포인터(Arrays and Pointers)
  - 배열로 선언된 변수는 배열의 크기 만한 메모리 블록의 시작 주소를 가리키는 포인터와 같이 여겨집니다.
  - 배열의 시작 위치를 가리키는 포인터를 만드는 것은 포인터에 다른 포인터를 할당하는 것과 정확히 같은 방식으로 수행됩니다.
```
short *ptr;
short array[10];
ptr = array;
```
  - 그런 후 포인터 자체가 배열인 듯이 포인터를 통해 배열에 든 값에 접근할 수 있습니다.
  - 배열을 가리키는 포인터와 배열의 유일한 차이점은 컴파일러가 배열에 필요한 저장 공간을 기록하기 위한 몇 가지 확장된 정보를 유지한다는 것입니다.
  - 예를 들어 배열과 포인터 둘에 sizeof 연산을 한다면 sizeof (ptr) 연산에서 포인터 자체가 점유하는 크기를 얻는 반면,
  - 배열의 sizeof 결과로 전체 배열이 점유하는 크기를 얻게 됩니다.

- 동적 메모리 할당(Dynamic Memory Allocation)
  - 포인터의 또 다른 기능은 컴파일 시점에 정의된 변수를 위해서가 아닌, 프로그램 실행 시점에 동적으로 할당되는(종종 이러한 메모리를 heap이라고 합니다) 메모리의 주소를 붙들어 둘 수 있다는 것입니다.
  - 실행 시 메모리 할당을 위해서 C언어에서는 malloc 함수를 제공하고 있습니다.
  - 이 함수는 필요한 크기의 메모리를 할당하고, 할당된 메모리에 대한 포인터를 반환합니다.
  - 메모리 블럭을 제거하기 위해 C언어에서는 free 함수를 제공하고 있습니다.
  - 이 함수는 포인터를 인자로 받습니다.
```
- 5개의 정수형 메모리 블록을 동적으로 생성하고 제거하는 코드입니다.
int account = 5;
int *arr = malloc(count * sizeof(int));
...
free(arr);
- count * sizeof(int) 부분은 배열을 위해 필요한 메모리의 크기를 배열 요소의 개수와 각 요소의 자료형의 크기를 곱하여 계산합니다.
```

- 함수 포인터(Function Pointers)
  - 데이터와 같이 실행 코드 또한 메모리에 저장됩니다. 따라서 함수의 주소 또한 얻을 수 있습니다.
  - 문제는 이런 목적으로 어떤 자료형의 포인터를 사용할 것인가입니다.
  - 일반적으로 함수의 주소를 저장하는데 함수 포인터를 사용합니다.
  - 함수 포인터를 사용하여 간접적으로 함수를 호출할 수 있습니다.
  - 하지만 함수 포인터를 다루는 데는 몇 가지 제약이 있습니다.
  - 함수 포인터는 순서가 없기(함수는 메모리 어디나 저장될 수 있습니다)때문에 할당과 간접 지정에 제약이 있으며, 함수 포인터에 산술연산을 할 수 없습니다.
```
- 함수 포인터의 생성과 사용에 대한 예시입니다.
int (*fptr) (int)
fptr = function1;
printf("function1 of 0 is : %d\n", fptr(5));
fptr = function2;
printf("function2 of 0 is : %d\n", fptr(10));
- 먼저 정수형 인자를 받는 함수를 가리키는 포인터를 fptr이라는 이름으로 생성합니다.
그리고 나서 fptr이 function1을 가리키도록 한 후, 포인터 fptr를 통해 function1의 인자가 5일 때 실행 결과를 출력합니다.
- 끝으로 fptr이 function2를 가리키도록 한 후, 똑같은 방법으로 function2가 인자 10을 가지고 실행한 결과를 출력합니다.
```

### 1.7 파라미터 전달 기법(Parameter Passing Techniques)
- 실제 변수와 형식 변수(Actual and Formal Parameters)
  - 함수 B()가 다른 함수 A()에 의해 호출된다고 가정해 봅시다.
  - 이 경우, A는 "호출자 함수(caller function)" 그리고 호출된 B는 "피호출 함수 혹은 피호출자 함수(callee function)"라 부릅니다.
  - 또한 A가 B에게 보내는 인자를 "실제 매개 변수(actual argument)"라하며, B함수의 파라미터는 "형식 매개 변수(formal argument)"라 합니다.

```
- func은 main 함수에서 호출됩니다.
- main 함수는 호출자 함수이고 func은 피호출자 함수입니다.
- 또한 func의 인자 param1과 param2는 형식 매개변수이고 main 함수의 i, j는 실제 매개 변수입니다.

int main() {
  long i = 1;
  double j = 2;
  func(i, j); // 실제 매개 변수 i, j와 함께 func 함수 호출
}

// 형식 매개 변수를 통한 func 함수 선언
void func(long param1, double param2) {
}
```

- 파라미터 전달의 의미(Semantics of Parameter Passing)
  - 논리적으로 봤을 때, 파라미터 전달은 다음과 같이 의미적으로 나누어 볼 수 있습니다.
  - 입(IN): 호출자(Caller)에서 피호출자(Callee)에게 정보를 전달합니다. 형식 매개 변수는 실제 매개 변수에서 값을 취하지만, 실제 매개 변수에게 값을 전달할 수는 없습니다.
  - 출(OUT): 피호출자가 호출자 내에 값을 쓸 수 있습니다.형식 매개 변수는 피호출자는 실제 매개 변수를 통해 값을 전달할 수 있지만 실제 매개 변수를 통해 값을 얻을 수는 없습니다.
  - 입/출(IN/OUT): 호출자는 피호출자에 의해 갱신이 가능한 변수의 값을 전달합니다. 형식 매개 변수는 실제 매개 변수에서 값을 획득하거나 전달할 수 있습니다.

- 언어별 파라미터 
  - 전달 기법 지원
    - Pass by value
      - 지원 언어: C, Pascal, Ada, Scheme, Algol68
    - Pass by result
      - 지원 언어: Ada
    - Pass by value-result
      - 지원 언어: Fortran, sometimes Ada
    - Pass by reference
      - 지원 언어: C(포인터를 사용), Fortran, Pascal var params, Cobol
    - Pass by name
      - 지원 언어: Algol60

  - 값에 의한 전달(Pass by Value)
    - 이 방법은 의미적으로 IN 방식을 사용합니다.
    - 형식 매개 변수는 형식 매개 변수와 함께 선언된 프로시저, 함수 혹은 서브 프로그램 유효범위 내의 새로운 지역 변수와 같습니다.
    - 실제 매개 변수의 값은 형식 매개 변수를 초기화하는데 사용됩니다. 변경된 형식 매개 변수는 호출자로 재전달할 수 없습니다.
    - 값에 의한 전달이 사용되면 형식 매개 변수는 스택 상에 지역 변수와 값이 할당됩니다.
    - 이 방법은 종종 "값에 의한 호출"이라 불립니다.
    - 이 방식의 장점은 실제 매개 변수가 변경 없이 유지된다는 것입니다.
    - 값에 의한 전달 방법은 값의 복사에 의해 구현되며 다음과 같은 단점이 있습니다.
      - 저장공간 할당에 의한 비효율성
      - 값 복사에 의한 비효율성
      - 객체와 배열에 대한 복사는 비용이 많이 들어감
```
- main 함수는 func 함수에 두 개의 값(5와 7)을 전달합니다.
- func 함수는 전달 받은 두 개의 값을 복사하고 a, b라는 이름의 변수로 다룹니다.
- func 함수는 변수 a의 값을 변경합니다.
- 다시 제어가 main으로 넘어왔을 때 실제 매개 변수 x와 y의 값은 변경되지 않습니다.
void func(int a, int b) {
  a += b;
  printf("In func, a=%d b=%d\n", a, b);
}

int main(void) {
  int x=5, y=7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}

- 출력결과: func 함수에서 a = 12, b = 7, main 함수에서 x = 5, y = 7
```

  - 결과에 의한 전달(Pass by Result)
    - 이 방법은 의미적으로 OUT 방식을 사용합니다.
    - 형식 매개 변수는 함수 범위 내의 새로운 지역 변수와 같습니다.
    - 어떠한 값도 실제 매개 변수에서 형식 매개 변수로 전달되지 않습니다.
    - 단지 제어가 호출자에게 넘어갈 때, 형식 매개 변수의 값이 실제 매개 변수로 전달됩니다.
    - 이 방식은 흔히 "결과에 의한 호출(call by result)"이라고 불립니다.
    - 실제 매개 변수는 단위 변수여야 하는데, foo(x), foo(a[1])은 바른 사용법이지만 foo(3), foo(x*y)는 잘못된 사용법입니다.

  - 매개 변수 충돌 발생 가능성(Parameter collisions can occur)
    - 이 설명을 위해 함수 write(p1, p1)이 있다고 가정해 봅시다.
    - write 함수가 서로 다른 이름을 가진 형식 매개 변수를 가지고 있다고 한다면 어떤 값이 p1에 저장될까요?
    - 실제 매개 변수에 값이 복사되는 순서에 따라 값이 결정됩니다.
    - 일반적으로 결과에 의한 전달 방식은 복사에 의해 구현되는데 다음과 같은 단점이 있습니다.
      - 저장 공간 할당에 의한 비효율성
      - 값 복사에 의한 비효율성
      - 객체와 배열에 대해 복사는 비용이 많이 들어가는 작업임
      - 실제 매개 변수를 형식 매개 변수의 초기화에 사용할 수 없음
```
- main 함수는 x, y 두 개의 변수를 사용합니다.
- 두 변수 모두 func 함수에 전달됩니다.
- 결과에 의한 전달 방식을 사용하고 있어 변수 x, y의 값은 형식 매개 변수에 복사되지 않을 것이기 때문에 func 함수의 변수 a와 b는 반드시 자체적으로 초기화되어야 합니다.
- 그러나 func 함수 내에서 변수 b만이 초기화됩니다. 따라서 변수 a의 값은 알 수 없는 반면, 변수 b의 값은 5가 됩니다.
- 함수가 실행되고 나면 변수 a, b의 값은 변수 x, y로 복사됩니다.
void func(int a, int b) {
  b = 5;
  a += b;
  printf("In func, a=%d b=%d d\n", a, b);
}

int main(void) {
  int x=5, y=7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}

-> 출력: func 함수에서 a = 쓰레기 값(garbage), b = 5, main 함수에서 x = 쓰레기 값(garbage), y = 5
```

  - 값과 결과에 의한 전달(Pass by Value-Result)
    - 이 방법은 의미적으로 IN/OUT 방식의 특성을 사용합니다.
    - 이것은 값에 의한 전달과 결과에 의한 전달을 혼합한 것입니다.
    - 형식 매개 변수는 함수 범위 내의 새로운 지역 변수와 같습니다.
    - 실제 매개 변수는 형식 매개 변수를 초기화하는데 사용됩니다.
    - 제어가 호출자로 다시 넘어오기 직전에 형식 매개 변수의 값들이 실제 매개 변수의 값에 복사됩니다.
    - 이 방법은 흔히 "값과 결과에 의한 호출(call by value-result)"이라고 불립니다.
    - "값과 결과에 의한 전달"은 "값에 의한 전달"과 "결과에 의한 전달"의 특징을 공유합니다.
    - 단점은 저장 공간과 값의 복사 비용이 두 배가 든다는 것과 "결과에 의한 전달"시 실제 파라미터에 할당되는 순서와 연관된 문제도 가지고 있습니다.
    - 그래서 이 방법은 장단점을 하나씩 가지고 있습니다.
```
- 코드에서 main 함수는 x, y 두 변수를 사용합니다.
- 두 변수 모두 func 함수로 전달됩니다.
- 여기서 값과 결과에 의한 전달 방식을 사용하기 때문에 x, y 값은 형식 매개 변수로 복사됩니다.
- 결과적으로 func 함수의 변수 a, b는 각각 5와 7을 가지게 되고 func 함수 내에서 a와 b값은 각각 10과 5로 변경됩니다.
- 함수 실행이 끝난 후 a와 b의 값은 x와 y로 복사됩니다.
- 이 방법의 단점은 각각의 변수가 새로 할당되어 생성된다는 것입니다.

void func(int a, int b) {
  b = 5; a += b;
  printf("In func, a=%d b=%d\n", a, b);
}

int main(void) {
  int x = 5, y = 7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}
=> func 함수에서 a = 10, b = 5, main 함수에서 x = 10, y = 5
```

  - 참조에 의한 전달(Pass by Reference)
    - 이 방법은 의미적으로 IN/OUT 방식의 특성을 사용합니다.
    - 형식 매개 변수는 실제 매개 변수의 별칭이며, 형식 매개 변수에 대한 수정은 전달된 실제 매개 변수에도 영향을 줍니다.
    - 이 방법은 흔히 "참조에 의한 호출(call by reference or aliasing)"이라고 불립니다.
    - 이 방법은 할당 공간과 시간에 있어서 효율적입니다.
    - 이 방식의 단점은 다음과 같습니다.
      - 수많은 잠재적인 경우가 발생할 수 있습니다.
      - 프로그램 가독성이 떨어집니다.
```
- C언어에서 함수가 호출될 때 포인터 값과 함께 포인터 파라미터가 초기화됩니다.
- 참조로 전달되기 때문에 함수 swapnum()을 호출하면 실제 매개 변수 a, b도 변경됩니다.
void swapnum(int *I, int *j) {
  int temp=I; i=j; j=temp;
}

int main(void) {
  int a=10, b=20;
  swapnum(&a, &b);
  printf("A is %d and B is %d\n", a, b);
  return 0;
}
=> A는 20, B는 10
```

  - 이름에 의한 전달(Pass by Name)
    - Algol 언어에서는 입출력 파라미터를 위해 "참조에 의한 전달" 보다 "이름에 의한 전달"이라는 훨씬 강력한 메커니즘이 사용됩니다.
    - 본질적으로 변수를 상징하는 이름을 전달하여 값을 획득하거나 갱신할 수 있습니다.
    - 예를 들어 C[j]의 값을 두 배로 만들기 위해 아래와 같은 프로시저에 변수명을 전달합니다.
```
procedure double (x)
  real x;
begin
  x:=x*2
end;
```
    - 일반적으로 이름에 의한 전달의 결과는 위 프로시저를 double(C[j])로 호출하면 프로시저 내 변수가 c[j]:c[j]*2와 같이 해석되는 것처럼, 프로시저 호출에 전달되는 매개 변수가 프로시저 내의 해당 파라미터를 문자적으로 대치하게 됩니다.
    - 주의할 것은 호출되는 프로시저 내 호출자의 변수와 동일한 이름의 변수가 있다면 호출자, 피호출자 전체에서 유일한 변수명으로 재정의해야 합니다.
    - 명칭에 의한 호출은 다음과 같은 메커니즘으로 구현됩니다.
      - 1. 형식 파라미터가 사용될 때마다 인자의 명칭이 전달되는 파라미터의 명칭으로 덮어 써집니다.
      - 2. 프로시저는 덮어써진 명칭을 사용해 해당 인수의 값을 변경함으로써 전달된 변수의 값을 변경시킬 수 있습니다.
      
      
### 1.8 바인딩(Binding)
- 앞서 모든 변수들이 메모리와 연관된다는 것을 보았습니다.
- 최상위 수준에서 바인딩은 이름(변수, 배열, 라벨, 절차 등의 명칭)을 그것이 포함하는 것(메모리 주소, 데이터 형 또는 실제 값)에 연결하는 작업입니다.

- 바인딩 시점(Binding Times)
  - 프로그램의 생명주기를 기준으로, 바인딩은 다양한 시점에 발생할 수 있으며, 다음 중 한 군데에서 발생할 수 있습니다.
    - 언어 설계 시(Language design time)
      - 연산자와 연산의 바인딩(예, 산술 연산자 "+" 기호와 더하기 연산)
    - 언어 구현 시(Language implementation time)
      - 데이터 유형과 데이터 유형이 가질 수 있는 값의 바인딩(예, "int"형 선언과 int 형이 가질 수 있는 값의 범위)
    - 프로그램 작성 시(Program writing time)
      - 알고리즘, 데이터 구조, 모듈 이름에 대한 바인딩
    - 컴파일 시(Compile time)
      - 변수와 데이터 유형을 바인딩
    - 링크 시(Link time)
      - 메모리 내의 프로그램 전체 레이아웃(개별 모듈(라이브러리))을 확정
    - 로드 시(Load time)
      - 물리적 주소 선택(C언어에서 정적 변수는 로드할 때 메모리 셀에 바인딩)
    - 실행 시(Run time)
      - 변수에 메모리에 위치한 값을 바인딩

- 기본적으로 바인딩에는 정적, 동적 두 가지 유형이 있습니다.
  - 정적 바인딩(Static Binding - Early binding)
    - 정적 바인딩은 프로그램 실행 이전에 이루어지며 실행 중에 변경되지 않습니다. 이를 종종 "이른 바인딩(early binding)"이라고 부릅니다.
    - 정적 바인딩의 예
      - C언어에서 상수에 값을 바인딩
      - C언어에서 함수의 정의에 함수 호출을 바인딩
  - 동적 바인딩(Dynamic Binding - Late binding)
    - 동적 바인딩은 프로그램이 실행되는 동안 발생하거나 변경되며, 이를 종종 "늦은 바인딩(late binding)"이라 부릅니다.
    - 동적 바인딩의 예
      - 메모리 주소와 포인터 변수를 바인딩
      - C++에서 가상 멤버함수 정의에 
      
## Chapter 02. INTRODUCTION

## Chapter 03. 재귀와 역추적

## Chapter 04. 연결 리스트

## Chapter 05. 스택

## Chapter 06. 큐

## Chapter 07. 트리

## Chapter 08. 우선 순위 큐와 힙

## Chapter 09. 그래프 알고리즘

## Chapter 10. 정렬

## Chapter 11. 검색

## Chapter 12. 선택 알고리즘

## Chapter 13. 심볼 테이블

## Chapter 14. 해싱

## Chapter 15. 문자열 알고리즘

## Chapter 16. 알고리즘 디자인 기술

## Chapter 17. 탐욕 알고리즘

## Chapter 18. 분할 정복 알고리즘

## Chapter 19. 동적 계획법

## Chapter 20. 복잡도 클래스

## Chapter 21. 디자인(설계) 인터뷰 질문들

## Chapter 22. 운영체제 시스템 개념

## Chapter 23. 컴퓨터 네트워크 기본

## Chapter 24. 데이터베이스 개념

## Chapter 25. 대답하기 어려운 문제들

## Chapter 26. 기술 이외의 조언

## Chapter 27. 그밖의 개념들


