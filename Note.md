# CodingInterviewQuestion


## Chapter 01. 프로그래밍 기초
### 1.1 변수(Variables)
- 컴퓨터 공학에서도 변수와 데이터를 유지하기 위해 같은 기능을 하는 무엇인가가 필요합니다.


### 1.2 자료형(Data Types)
- 프로그래밍 언어에서 자료형은 미리 특징지어진 값들을 가지는 데이터의 집합입니다.
- 예를 들면, integer(정수), floating point unit number(부동소수점 수), character(문자), string(문자열) 등이 있습니다.
- 컴퓨터의 메모리는 모두 0 또는 1로 채워집니다. 우리가 어떤 문제를 풀어야 하고 이를 0과 1로 코드화 한다는 것은 매우 어려운 일일 것입니다.
- 이를 돕기 위해 프로그래밍 언어와 해당 언어의 컴파일러는 자료형을 제공합니다.
- 기본적으로 자료형에는 다음 두 가지 유형이 있습니다.
  - 시스템 정의 자료형(원시 자료형: Primitive data types)
    - 시스템에 의해 정의된 자료형이 원시 자료형입니다.
    - 많은 프로그래밍 언어들이 제공하는 원시 자료형으로는 int, float, char, double, boolean 등이 있습니다.
    - 같은 원시 자료형이라 할 지라도 서로 다른 언어에서 서로 다른 크기를 가질 수 있습니다.
    - 가질 수 있는 크기에 따라 가질 수 있는 값의 영역도 다릅니다.

  - 사용자 정의 자료형(User defined data types)
    - 시스템 정의 자료형들이 충분하지 않을 수 있으므로 대부분의 프로그래밍 언어들이 '사용자 정의 자료형'이라 부르는 자신들만의 자료형을 선언할 수 있도록 하고 있습니다.
    - 좋은 예가 C/C++의 구조체와 Java의 클래스입니다.


### 1.3 자료 구조(Data Structure)
- 자료 구조는 컴퓨터 내에서 유용하게 사용되도록 데이터를 저장하고 구조화하는 특정한 방법을 말합니다.
- 즉, 자료 구조는 데이터를 저장하고 구조화하는 특별한 형태입니다.
- 자료 구조는 구성요소들을 어떻게 구조화하였는가에 따라 두 가지 유형으로 분류됩니다.
- 선형 자료 구조(Linear data structures)
  - 선형 자료 구조의 구성 요소들은 순차적으로 접근되지만, 모든 요소들이 반드시 순차적으로 저장되지는 않습니다(Linked Lists)
  - 예: 연결 리스트, 스택, 큐
- 비선형 자료 구조(Non-linear data structures)
  - 자료 구조의 구성 요소들이 비순차적인 순서로 저장되고 접근됩니다.
  - 예: 트리, 그래프


### 1.4 추상 자료형(Abstract Data Types - ADTs)
- 일반적으로 자료 구조와 연산을 결합하여 추상 자료형(ADTs)이라고 부릅니다.
- 추상 자료형은 데이터 선언 부분과 연산자 선언 두 부분으로 구성됩니다.
- 일반적으로 사용되는 추상 자료형은 연결 리스트, 스택, 큐, 우선 순위 큐, 이진 트리, 딕셔너리, 분리 집합(Union과 Find), 해시 테이블, 그래프 등이 있습니다.
- 예를 들어 스택은 자료 구조에 데이터를 저장할 때 LIFO(Last-In-First-Out) 메커니즘을 사용합니다.
- 추상 자료형을 정의하면서 구현의 세부 정보에 대해서는 신경쓰지 않습니다. 이는 우리가 필요할 때만 구체화됩니다.
- 여러 추상 자료형들은 각자의 특징에 맞는 용도를 가지고 있으며, 몇몇 추상 자료형은 특정 업무에 고도로 전문화되어 있습니다.


### 1.5 메모리와 변수(Memory and Variables)
- 메모리는 바이트의 배열처럼 다룰 수 있으며, 각각의 위치는 주소로 식별됩니다.
- 보통 0번 주소는 유효한 메모리 주소가 아닙니다.
- 모든 바이트를 가리키는 주소는 integer라는 것을 이해하는 게 중요합니다.
- 어떤 위치를 읽거나 쓰기 위해 CPU는 메모리 제어기(memory controller)에 그 위치를 전달하여 접근합니다.
- 변수를 생성할 때(예를 들어 C에서 int X), 컴파일러는 연속된 메모리 블록을 할당하고 이 크기는 변수의 크기에 달려 있습니다.
- 컴파일러는 또한 변수 이름 X와 할당된 첫 번째 바이트의 주소를 연결짓는 내부적인 태그를 유지합니다(흔히 symbol table이라 부릅니다).
- Size of a Variables
  - Sizeof 연산자는 변수의 크기(변수가 얼마나 많은 메모리를 차지하고 있는가)를 알아내는데 사용됩니다. 예를 들어 어떤 컴퓨터에서 Sizeof(X)가 4를 반환하였다면 integer는 메모리에서 4개의 연속된 byte가 필요하다는 것입니다. 또 X의 주소가 2000이라고 한다면 실제 X에 의해서 사용되는 메모리 주소는 2000, 2001, 2002 그리고 2003입니다.
- Address of a Variables
  - C언어에서 참조 연산자(address-of: &)를 사용하여 변수의 주소를 얻을 수 있습니다. 아래는 변수 X의 주소를 찍는 코드입니다. 일반적으로 주소 값이 클 경우 간단하고 쉽게 이해하도록 16진수로 출력됩니다.


### 1.6 포인터(Pointers)
- 포인터는 다른 변수의 주소를 보관할 수 있는 변수입니다.
- 포인터의 선언(Declare of Pointers)
  - 포인터를 선언하기 위해서는 포인터가 가리킬 변수의 자료형을 명시해야 합니다.
  - 즉, 주소를 저장하고자 하는 변수에 대한 자료형이 필요합니다.
  - 포인터 선언의 예시
```
int *ptr1;
float *ptr2;
unsigned int *ptr3;
char *ptr4; void *ptr5;

=> ptr1은 int형 변수를 가리킬 수 있는 포인터이고 
ptr2는 float형을, 
ptr3은 unsigned int형을,
ptr4는 char형을 가리킬 수 있는 포인터입니다.
끝으로 ptr5는 형을 지정하지 않아 무엇이든지 가리킬 수 있는 포인터입니다. 이러한 포인터를 void형 포인트라고 부르는데 void형 포인터는 몇 가지 제약이 있습니다.
```
- 포인터의 사용(Pointers Usages)
  - 포인터는 주소를 담습니다. 즉, 변수의 주소를 할당할 수 있습니다.
```
int X = 10;
int *ptr = &X;
- 코드에서 X라는 이름의 정수형(int) 변수를 선언하고 10으로 값을 초기화합니다. 그리고 정수형 포인터 ptr을 생성하고 X의 주소 값을 할당합니다.
- 이를 "X를 가리키는 포인터 ptr을 만들다"라고 합니다.
- 포인터로 할 수 있는 일반적인 연산은 포인터가 가리키는 메모리 주소에 있는 값을 획득하는 "간접지정(indirection)"입니다.
- 간접지정 연산자는 '*' 기호로 표시됩니다.
- 포인터를 선언할 때 사용하는 기호와 같으나 둘을 혼동해서는 안됩니다.
```
  - ptr이 가리키는 메모리 상의 값에 접근하려고 할 때 '*ptr'과 같이 사용합니다. 다음 코드는 포인터의 간접 지정을 보여줍니다.
```
int X = 10;
int *ptr = &X;
printf("X의 값: %d\n", X);
printf("ptr이 가리키는 주소: %p\n", ptr);
printf("주소에 있는 값: %d\n", *ptr);
*ptr = 25;
printf("X가 가진 값: %d\n", X);
- 전과 동일하게 변수 X(10이 출력)와 포인터 ptr을 선언하고 X와 ptr을 출력합니다.
- ptr이 가진 값은 변수 X의 주소 값이며 다음 줄에서는 포인터 ptr이 가리키는 주소에 들어있는 값을 출력합니다(마찬가지로 10이 출력)
- 끝으로 포인터 ptr이 가리키는 주소에 들어있는 값을 25로 변경하면 변수 X의 값이 변경되어 출력되는 것을 확인할 수 있는데, 이는 포인터 ptr이 변수 X의 주소 값을 가지고 있으며 ptr이 가리키는 주소에 든 값을 변경하면 변수 X의 값이 변경되기 때문입니다.
- 모든 형을 가리킬 수 있는 void 포인터의 한 가지 제약은 간접 참조를 할 수 없다는 것인데, 이는 각기 다른 자료형이 차지하는 메모리의 크기가 서로 다르기 때문입니다.
- 예를 들어 32비트 컴퓨터에서 int형은 4바이트를, short 형은 2바이트를 차지하는데, 컴파일러는 가리키는 주소에서 전체 값을 읽어 들이기 위해 얼마나 많은 바이트를 읽어야 할지 알아야 하지만 void 포인터는 그렇게 할 수 없기 때문입니다.
```

- 포인터 연산(Pointer Manipulation)
  - 포인터의 또 다른 유용함은 산술 연산을 적용할 수 있다는 것입니다. 어차피 포인터가 정수형이라고 했으니 당연한 것이 아닐까 하겠지만, 포인터의 산술 연산에는 미묘한 차이가 있습니다.
```
char *cptr = (char*)2;
printf("cptr before: %p", cptr);
cptr++;
printf("cptr after: %p", cptr);
- cptr라는 포인터를 선언하고 2라는 주소를 할당한 후 첫 번째 출력(주소 2가 출력)을 하였습니다.
- 그리고 포인터를 증가시킨 후 다시 출력(3이 출력)하였습니다.
- 정확히 기대하던 대로 하나의 값이 증가하여 출력 되었습니다.

int *iptr = (int*)2;
printf("iptr before: %p", iptr);
iptr++;
printf("iptr after: %p \n", iptr);
- iptr before는 2, after는 6으로 출력됩니다.
- 포인터를 1 증가시켰을 뿐인데 이런 일이 발생하는 것은 변수의 sizeof 값에 있습니다.
- 컴퓨터에서 int의 길이는 4바이트 입니다.
- 즉, 주소 2에 정수형(int) 변수가 위치하고 있다면 이 변수는 메모리 주소 2, 3, 4, 5를 점유하게 되며, 다음 정수형에 접근하기 위해 6, 7, 8, 9 주소를 찾게 됩니다.
- 따라서 우리가 정수형 포인터에 1을 증가시키는 연산을 하게 되면 정수형 변수의 다음 위치 값을 되돌려 주기 때문에 이렇게 되는 것입니다.
- void 포인터의 또 다른 제약은 컴파일러가 얼마나 이동해야 다음 값이 있는지 알 수 없기 때문에 포인터에 산술연산을 할 수 없다는 것입니다.
- 그래서 void 포인터는 사용하기 전에 나중에 반환해야 하는 특정 포인터 유형의 주소를 보관하기 위해서만 사용할 수 있습니다.
```

- 배열과 포인터(Arrays and Pointers)
  - 배열로 선언된 변수는 배열의 크기 만한 메모리 블록의 시작 주소를 가리키는 포인터와 같이 여겨집니다.
  - 배열의 시작 위치를 가리키는 포인터를 만드는 것은 포인터에 다른 포인터를 할당하는 것과 정확히 같은 방식으로 수행됩니다.
```
short *ptr;
short array[10];
ptr = array;
```
  - 그런 후 포인터 자체가 배열인 듯이 포인터를 통해 배열에 든 값에 접근할 수 있습니다.
  - 배열을 가리키는 포인터와 배열의 유일한 차이점은 컴파일러가 배열에 필요한 저장 공간을 기록하기 위한 몇 가지 확장된 정보를 유지한다는 것입니다.
  - 예를 들어 배열과 포인터 둘에 sizeof 연산을 한다면 sizeof (ptr) 연산에서 포인터 자체가 점유하는 크기를 얻는 반면,
  - 배열의 sizeof 결과로 전체 배열이 점유하는 크기를 얻게 됩니다.

- 동적 메모리 할당(Dynamic Memory Allocation)
  - 포인터의 또 다른 기능은 컴파일 시점에 정의된 변수를 위해서가 아닌, 프로그램 실행 시점에 동적으로 할당되는(종종 이러한 메모리를 heap이라고 합니다) 메모리의 주소를 붙들어 둘 수 있다는 것입니다.
  - 실행 시 메모리 할당을 위해서 C언어에서는 malloc 함수를 제공하고 있습니다.
  - 이 함수는 필요한 크기의 메모리를 할당하고, 할당된 메모리에 대한 포인터를 반환합니다.
  - 메모리 블럭을 제거하기 위해 C언어에서는 free 함수를 제공하고 있습니다.
  - 이 함수는 포인터를 인자로 받습니다.
```
- 5개의 정수형 메모리 블록을 동적으로 생성하고 제거하는 코드입니다.
int account = 5;
int *arr = malloc(count * sizeof(int));
...
free(arr);
- count * sizeof(int) 부분은 배열을 위해 필요한 메모리의 크기를 배열 요소의 개수와 각 요소의 자료형의 크기를 곱하여 계산합니다.
```

- 함수 포인터(Function Pointers)
  - 데이터와 같이 실행 코드 또한 메모리에 저장됩니다. 따라서 함수의 주소 또한 얻을 수 있습니다.
  - 문제는 이런 목적으로 어떤 자료형의 포인터를 사용할 것인가입니다.
  - 일반적으로 함수의 주소를 저장하는데 함수 포인터를 사용합니다.
  - 함수 포인터를 사용하여 간접적으로 함수를 호출할 수 있습니다.
  - 하지만 함수 포인터를 다루는 데는 몇 가지 제약이 있습니다.
  - 함수 포인터는 순서가 없기(함수는 메모리 어디나 저장될 수 있습니다)때문에 할당과 간접 지정에 제약이 있으며, 함수 포인터에 산술연산을 할 수 없습니다.
```
- 함수 포인터의 생성과 사용에 대한 예시입니다.
int (*fptr) (int)
fptr = function1;
printf("function1 of 0 is : %d\n", fptr(5));
fptr = function2;
printf("function2 of 0 is : %d\n", fptr(10));
- 먼저 정수형 인자를 받는 함수를 가리키는 포인터를 fptr이라는 이름으로 생성합니다.
그리고 나서 fptr이 function1을 가리키도록 한 후, 포인터 fptr를 통해 function1의 인자가 5일 때 실행 결과를 출력합니다.
- 끝으로 fptr이 function2를 가리키도록 한 후, 똑같은 방법으로 function2가 인자 10을 가지고 실행한 결과를 출력합니다.
```

### 1.7 파라미터 전달 기법(Parameter Passing Techniques)
- 실제 변수와 형식 변수(Actual and Formal Parameters)
  - 함수 B()가 다른 함수 A()에 의해 호출된다고 가정해 봅시다.
  - 이 경우, A는 "호출자 함수(caller function)" 그리고 호출된 B는 "피호출 함수 혹은 피호출자 함수(callee function)"라 부릅니다.
  - 또한 A가 B에게 보내는 인자를 "실제 매개 변수(actual argument)"라하며, B함수의 파라미터는 "형식 매개 변수(formal argument)"라 합니다.

```
- func은 main 함수에서 호출됩니다.
- main 함수는 호출자 함수이고 func은 피호출자 함수입니다.
- 또한 func의 인자 param1과 param2는 형식 매개변수이고 main 함수의 i, j는 실제 매개 변수입니다.

int main() {
  long i = 1;
  double j = 2;
  func(i, j); // 실제 매개 변수 i, j와 함께 func 함수 호출
}

// 형식 매개 변수를 통한 func 함수 선언
void func(long param1, double param2) {
}
```

- 파라미터 전달의 의미(Semantics of Parameter Passing)
  - 논리적으로 봤을 때, 파라미터 전달은 다음과 같이 의미적으로 나누어 볼 수 있습니다.
  - 입(IN): 호출자(Caller)에서 피호출자(Callee)에게 정보를 전달합니다. 형식 매개 변수는 실제 매개 변수에서 값을 취하지만, 실제 매개 변수에게 값을 전달할 수는 없습니다.
  - 출(OUT): 피호출자가 호출자 내에 값을 쓸 수 있습니다.형식 매개 변수는 피호출자는 실제 매개 변수를 통해 값을 전달할 수 있지만 실제 매개 변수를 통해 값을 얻을 수는 없습니다.
  - 입/출(IN/OUT): 호출자는 피호출자에 의해 갱신이 가능한 변수의 값을 전달합니다. 형식 매개 변수는 실제 매개 변수에서 값을 획득하거나 전달할 수 있습니다.

- 언어별 파라미터 
  - 전달 기법 지원
    - Pass by value
      - 지원 언어: C, Pascal, Ada, Scheme, Algol68
    - Pass by result
      - 지원 언어: Ada
    - Pass by value-result
      - 지원 언어: Fortran, sometimes Ada
    - Pass by reference
      - 지원 언어: C(포인터를 사용), Fortran, Pascal var params, Cobol
    - Pass by name
      - 지원 언어: Algol60

  - 값에 의한 전달(Pass by Value)
    - 이 방법은 의미적으로 IN 방식을 사용합니다.
    - 형식 매개 변수는 형식 매개 변수와 함께 선언된 프로시저, 함수 혹은 서브 프로그램 유효범위 내의 새로운 지역 변수와 같습니다.
    - 실제 매개 변수의 값은 형식 매개 변수를 초기화하는데 사용됩니다. 변경된 형식 매개 변수는 호출자로 재전달할 수 없습니다.
    - 값에 의한 전달이 사용되면 형식 매개 변수는 스택 상에 지역 변수와 값이 할당됩니다.
    - 이 방법은 종종 "값에 의한 호출"이라 불립니다.
    - 이 방식의 장점은 실제 매개 변수가 변경 없이 유지된다는 것입니다.
    - 값에 의한 전달 방법은 값의 복사에 의해 구현되며 다음과 같은 단점이 있습니다.
      - 저장공간 할당에 의한 비효율성
      - 값 복사에 의한 비효율성
      - 객체와 배열에 대한 복사는 비용이 많이 들어감
```
- main 함수는 func 함수에 두 개의 값(5와 7)을 전달합니다.
- func 함수는 전달 받은 두 개의 값을 복사하고 a, b라는 이름의 변수로 다룹니다.
- func 함수는 변수 a의 값을 변경합니다.
- 다시 제어가 main으로 넘어왔을 때 실제 매개 변수 x와 y의 값은 변경되지 않습니다.
void func(int a, int b) {
  a += b;
  printf("In func, a=%d b=%d\n", a, b);
}

int main(void) {
  int x=5, y=7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}

- 출력결과: func 함수에서 a = 12, b = 7, main 함수에서 x = 5, y = 7
```

  - 결과에 의한 전달(Pass by Result)
    - 이 방법은 의미적으로 OUT 방식을 사용합니다.
    - 형식 매개 변수는 함수 범위 내의 새로운 지역 변수와 같습니다.
    - 어떠한 값도 실제 매개 변수에서 형식 매개 변수로 전달되지 않습니다.
    - 단지 제어가 호출자에게 넘어갈 때, 형식 매개 변수의 값이 실제 매개 변수로 전달됩니다.
    - 이 방식은 흔히 "결과에 의한 호출(call by result)"이라고 불립니다.
    - 실제 매개 변수는 단위 변수여야 하는데, foo(x), foo(a[1])은 바른 사용법이지만 foo(3), foo(x*y)는 잘못된 사용법입니다.

  - 매개 변수 충돌 발생 가능성(Parameter collisions can occur)
    - 이 설명을 위해 함수 write(p1, p1)이 있다고 가정해 봅시다.
    - write 함수가 서로 다른 이름을 가진 형식 매개 변수를 가지고 있다고 한다면 어떤 값이 p1에 저장될까요?
    - 실제 매개 변수에 값이 복사되는 순서에 따라 값이 결정됩니다.
    - 일반적으로 결과에 의한 전달 방식은 복사에 의해 구현되는데 다음과 같은 단점이 있습니다.
      - 저장 공간 할당에 의한 비효율성
      - 값 복사에 의한 비효율성
      - 객체와 배열에 대해 복사는 비용이 많이 들어가는 작업임
      - 실제 매개 변수를 형식 매개 변수의 초기화에 사용할 수 없음
```
- main 함수는 x, y 두 개의 변수를 사용합니다.
- 두 변수 모두 func 함수에 전달됩니다.
- 결과에 의한 전달 방식을 사용하고 있어 변수 x, y의 값은 형식 매개 변수에 복사되지 않을 것이기 때문에 func 함수의 변수 a와 b는 반드시 자체적으로 초기화되어야 합니다.
- 그러나 func 함수 내에서 변수 b만이 초기화됩니다. 따라서 변수 a의 값은 알 수 없는 반면, 변수 b의 값은 5가 됩니다.
- 함수가 실행되고 나면 변수 a, b의 값은 변수 x, y로 복사됩니다.
void func(int a, int b) {
  b = 5;
  a += b;
  printf("In func, a=%d b=%d d\n", a, b);
}

int main(void) {
  int x=5, y=7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}

-> 출력: func 함수에서 a = 쓰레기 값(garbage), b = 5, main 함수에서 x = 쓰레기 값(garbage), y = 5
```

  - 값과 결과에 의한 전달(Pass by Value-Result)
    - 이 방법은 의미적으로 IN/OUT 방식의 특성을 사용합니다.
    - 이것은 값에 의한 전달과 결과에 의한 전달을 혼합한 것입니다.
    - 형식 매개 변수는 함수 범위 내의 새로운 지역 변수와 같습니다.
    - 실제 매개 변수는 형식 매개 변수를 초기화하는데 사용됩니다.
    - 제어가 호출자로 다시 넘어오기 직전에 형식 매개 변수의 값들이 실제 매개 변수의 값에 복사됩니다.
    - 이 방법은 흔히 "값과 결과에 의한 호출(call by value-result)"이라고 불립니다.
    - "값과 결과에 의한 전달"은 "값에 의한 전달"과 "결과에 의한 전달"의 특징을 공유합니다.
    - 단점은 저장 공간과 값의 복사 비용이 두 배가 든다는 것과 "결과에 의한 전달"시 실제 파라미터에 할당되는 순서와 연관된 문제도 가지고 있습니다.
    - 그래서 이 방법은 장단점을 하나씩 가지고 있습니다.
```
- 코드에서 main 함수는 x, y 두 변수를 사용합니다.
- 두 변수 모두 func 함수로 전달됩니다.
- 여기서 값과 결과에 의한 전달 방식을 사용하기 때문에 x, y 값은 형식 매개 변수로 복사됩니다.
- 결과적으로 func 함수의 변수 a, b는 각각 5와 7을 가지게 되고 func 함수 내에서 a와 b값은 각각 10과 5로 변경됩니다.
- 함수 실행이 끝난 후 a와 b의 값은 x와 y로 복사됩니다.
- 이 방법의 단점은 각각의 변수가 새로 할당되어 생성된다는 것입니다.

void func(int a, int b) {
  b = 5; a += b;
  printf("In func, a=%d b=%d\n", a, b);
}

int main(void) {
  int x = 5, y = 7;
  func(x, y);
  printf("In main, x=%d y=%d\n", x, y);
  return 0;
}
=> func 함수에서 a = 10, b = 5, main 함수에서 x = 10, y = 5
```

  - 참조에 의한 전달(Pass by Reference)
    - 이 방법은 의미적으로 IN/OUT 방식의 특성을 사용합니다.
    - 형식 매개 변수는 실제 매개 변수의 별칭이며, 형식 매개 변수에 대한 수정은 전달된 실제 매개 변수에도 영향을 줍니다.
    - 이 방법은 흔히 "참조에 의한 호출(call by reference or aliasing)"이라고 불립니다.
    - 이 방법은 할당 공간과 시간에 있어서 효율적입니다.
    - 이 방식의 단점은 다음과 같습니다.
      - 수많은 잠재적인 경우가 발생할 수 있습니다.
      - 프로그램 가독성이 떨어집니다.
```
- C언어에서 함수가 호출될 때 포인터 값과 함께 포인터 파라미터가 초기화됩니다.
- 참조로 전달되기 때문에 함수 swapnum()을 호출하면 실제 매개 변수 a, b도 변경됩니다.
void swapnum(int *I, int *j) {
  int temp=I; i=j; j=temp;
}

int main(void) {
  int a=10, b=20;
  swapnum(&a, &b);
  printf("A is %d and B is %d\n", a, b);
  return 0;
}
=> A는 20, B는 10
```

  - 이름에 의한 전달(Pass by Name)
    - Algol 언어에서는 입출력 파라미터를 위해 "참조에 의한 전달" 보다 "이름에 의한 전달"이라는 훨씬 강력한 메커니즘이 사용됩니다.
    - 본질적으로 변수를 상징하는 이름을 전달하여 값을 획득하거나 갱신할 수 있습니다.
    - 예를 들어 C[j]의 값을 두 배로 만들기 위해 아래와 같은 프로시저에 변수명을 전달합니다.
```
procedure double (x)
  real x;
begin
  x:=x*2
end;
```
    - 일반적으로 이름에 의한 전달의 결과는 위 프로시저를 double(C[j])로 호출하면 프로시저 내 변수가 c[j]:c[j]*2와 같이 해석되는 것처럼, 프로시저 호출에 전달되는 매개 변수가 프로시저 내의 해당 파라미터를 문자적으로 대치하게 됩니다.
    - 주의할 것은 호출되는 프로시저 내 호출자의 변수와 동일한 이름의 변수가 있다면 호출자, 피호출자 전체에서 유일한 변수명으로 재정의해야 합니다.
    - 명칭에 의한 호출은 다음과 같은 메커니즘으로 구현됩니다.
      - 1. 형식 파라미터가 사용될 때마다 인자의 명칭이 전달되는 파라미터의 명칭으로 덮어 써집니다.
      - 2. 프로시저는 덮어써진 명칭을 사용해 해당 인수의 값을 변경함으로써 전달된 변수의 값을 변경시킬 수 있습니다.
      
      
### 1.8 바인딩(Binding)
- 앞서 모든 변수들이 메모리와 연관된다는 것을 보았습니다.
- 최상위 수준에서 바인딩은 이름(변수, 배열, 라벨, 절차 등의 명칭)을 그것이 포함하는 것(메모리 주소, 데이터 형 또는 실제 값)에 연결하는 작업입니다.

- 바인딩 시점(Binding Times)
  - 프로그램의 생명주기를 기준으로, 바인딩은 다양한 시점에 발생할 수 있으며, 다음 중 한 군데에서 발생할 수 있습니다.
    - 언어 설계 시(Language design time)
      - 연산자와 연산의 바인딩(예, 산술 연산자 "+" 기호와 더하기 연산)
    - 언어 구현 시(Language implementation time)
      - 데이터 유형과 데이터 유형이 가질 수 있는 값의 바인딩(예, "int"형 선언과 int 형이 가질 수 있는 값의 범위)
    - 프로그램 작성 시(Program writing time)
      - 알고리즘, 데이터 구조, 모듈 이름에 대한 바인딩
    - 컴파일 시(Compile time)
      - 변수와 데이터 유형을 바인딩
    - 링크 시(Link time)
      - 메모리 내의 프로그램 전체 레이아웃(개별 모듈(라이브러리))을 확정
    - 로드 시(Load time)
      - 물리적 주소 선택(C언어에서 정적 변수는 로드할 때 메모리 셀에 바인딩)
    - 실행 시(Run time)
      - 변수에 메모리에 위치한 값을 바인딩

- 기본적으로 바인딩에는 정적, 동적 두 가지 유형이 있습니다.
  - 정적 바인딩(Static Binding - Early binding)
    - 정적 바인딩은 프로그램 실행 이전에 이루어지며 실행 중에 변경되지 않습니다. 이를 종종 "이른 바인딩(early binding)"이라고 부릅니다.
    - 정적 바인딩의 예
      - C언어에서 상수에 값을 바인딩
      - C언어에서 함수의 정의에 함수 호출을 바인딩
  - 동적 바인딩(Dynamic Binding - Late binding)
    - 동적 바인딩은 프로그램이 실행되는 동안 발생하거나 변경되며, 이를 종종 "늦은 바인딩(late binding)"이라 부릅니다.
    - 동적 바인딩의 예
      - 메모리 주소와 포인터 변수를 바인딩
      - C++에서 가상 멤버함수 정의에 멤버 함수의 호출을 바인딩

### 1.9 스코프(Scope)
- 스코프란 변수의 바인딩 변경이 없거나 최소한 변수의 재선언이 허락되지 않는 최대 범위를 말합니다.
- 프로그램 언어의 스코프 규칙은 바인딩과 밀접한 관계를 가지며 어떻게 변수와 관련된 이름을 참조할지를 결정합니다.
- 기본적으로 스코핑 방식에는 정적 스코핑(static scoping)과 동적 스코핑(dynamic scoping) 두 가지가 있습니다.
  - 정적 스코프(Static scope)
    - 정적 스코프는 프로그램의 물리적인 구조로 정의됩니다.
    - 스코프의 결정은 컴파일러에 의해 수행됩니다.
    - 이는 프로그램 텍스트를 검토하여 바인딩한다는 말이 됩니다.
    - 특정 정적 스코프를 둘러싼 바깥쪽의 정적 스코프를 모두 static ancestor라 부르며, 가장 가까운 바깥쪽의 정적 스코프를 static parent라 부릅니다.
- 변수는 동일한 이름의 클로저(closer) 변수를 통해 어떤 단위로 숨겨질 수 있습니다.
- Ada와 C++ 언어는 class_nam::name과 같은 방식으로 이러한 접근을 허용하고 있습니다.
- C와 Pascal을 포함해 대부분의 컴파일 언어는 정적 스코프 규칙을 사용합니다.
  - 동적 스코프(Dynamic scope)
    - 동적 스코프 규칙은 일반적으로 해석형 언어(Interpreted language)에서 사용합니다.
    - 이러한 언어들은 일반적으로 동적 스코프 규칙이 적용될 때 자료형에 대한 결정이 항상 가능하지는 않기 때문에 컴파일 시 자료형을 체크할 수 없습니다.
    - 동적 스코핑에 있어, 바인딩은 실행 시 제어의 흐름과 함수가 호출되는 순서에 따라 가장 가까운 활성 바인딩이 적용됩니다.
      
      
### 1.10 기억 영역 분류(Storage Classes)
- 기억 영역 분류는 변수 혹은 객체에 할당된 기억 영역(storage)과 이러한 할당이 얼마나 지속되어야 하는지를 결정하는 역할을 합니다.
- 또한 프로그램에서 변수들을 사용할 수 있는 영역인 스코프를 결정합니다.
- C언어에서는 4가지 기억 영역의 분류가 존재합니다.
  - 자동 기억 영역(Auto Storage Class)
    - 이것은 C언어에서 기본 기억 영역입니다.
    - 이 영역에 할당되는 변수를 자동변수라 하고 사용되는 함수 내에서 선언됩니다.
    - 또한 'auto' 키워드를 사용하여 자동변수를 선언할 수 있습니다(예: auto int number;).
    - 자동변수들은 함수가 호출될 때 자동으로 생성되고 함수가 종료될 때 제거됩니다.
    - 따라서 이 변수들은 선언된 함수의 private(local) 특성을 갖습니다.
    - 기억영역에 대한 지정자 없이 함수 내에서 선언된 변수는 기본적으로 자동변수입니다.
    - 일반적인 모든 main 함수의 지역 변수들은 비록 main 함수 내에서만 사용되더라도 프로그램 전체 생존 동안 살아있습니다.
    - 반복 구조에서 중첩된 변수는 고유한 자동변수입니다.
    - 자동변수는 또한 블록 내에서 선언될 수도 있습니다.
    - 이런 경우 자동변수는 그들이 선언된 블록 내에서만 의미를 가지게 됩니다.
    - 자동변수들은 초기화되지 않을 경우 쓰레기 값을 가지게 됩니다.

  - 외부 기억 영역
    - 이 영역에 할당되는 변수들은 함수 외부에서 선언됩니다.
    - 이러한 변수들은 프로그램 전체 생존주기 동안 살아있습니다.
    - 또한 전역 변수처럼 기본 값은 '0'입니다.
    - 지역 변수와 달리 이들은 프로그램 내 모든 함수에서 접근할 수 있습니다.
    - 지역 변수와 전역 변수의 이름이 동일할 경우 지역 변수가 전역 변수보다 우선합니다.
    - 종종 이러한 변수를 선언할 때 'extern' 키워드를 사용합니다.
    - 외부 변수는 선언 시점부터 프로그램 종료까지 사용할 수 있습니다.
    - 전역 변수(Global variables)
      - 한 번 전역 변수로 선언되면 모든 함수가 사용할 수 있으며 값을 변경할 수 있습니다.
      - 값이 변경된 이후 함수들은 변경된 값을 참조하게 됩니다.
  
  - 레지스터 기억 영역(Register Storage Class)
    - 이 변수들은 컴퓨터의 레지스터에 저장되고 "register int count;"와 같이 'register' 키워드를 사용하여 선언됩니다.
    - 레지스터는 메모리 접근 속도보다 매우 빠르기 때문에 자주 접근되는 변수들을 레지스터에 보관함으로써 프로그램의 속도를 보다 빠르게 할 수 있습니다.
    - 작은 수의 변수들만이 레지스터에 위치할 수 있기 때문에 이러한 목적에 맞는 변수를 선택할 때 주의해야 합니다.
    - C언어는 한번 제한점에 도달한 일반 변수들을 자동으로 레지스터 변수로 전환합니다.
    - 전역 변수를 레지스터 변수로 선언하면 프로그램의 생존 주기 동안 레지스터를 점유하게 되므로 피해야 합니다.

  - 정적 기억 영역(Static Storage Class)
    - 정적 변수들의 값은 프로그램이 종료될 때까지 지속됩니다.
    - 정적 변수들은 'static' 키워드를 사용하여 선언합니다.
    - 정적 변수는 선언 위치에 따라 외부 혹은 내부 유형으로 나뉘며 프로그램이 컴파일 될 때 단 한번 초기화됩니다.

  - 내부 정적 변수(Internal Static Variables)
    - 함수 내에서 정적으로 선언되고 할당된 변수입니다.
    - 내부 정적 변수의 스코프는 선언된 곳에서 프로그램이 끝날 때까지 확장되고 프로그램이 끝날 때까지 유지되는 것을 제외하면 자동 변수(일반 지역 변수)와 유사합니다.
    - 정적 지역 변수는 함수를 반복 호출할 때 값을 유지하는데 사용됩니다.

  - 외부 정적 변수(External Static Variables)
    - 외부 정적 변수는 프로그램의 가장 상위 레벨에 선언되어 프로그램의 모든 함수들이 사용할 수 있는 정적 변수입니다.
    - 이는 흔히 간단한 외부 변수처럼 보이지만, 외부 정적 변수는 선언된 파일 안에서만 사용할 수 있는 반면 외부 변수는 서로 다른 모듈의 파일에서도 사용할 수 있다는 차이점이 있습니다.

  - 정적 함수(Static Function)
    - 정적 선언은 함수의 스코프를 제어할 때도 사용됩니다.
    - 여러분이 어떤 함수를 선언된 모듈의 파일 내에서만 접근이 가능하고 다른 파일의 어떤 함수도 접근하지 못하도록 할 때 함수를 정적으로 선언합니다.


### 1.11 기억 영역의 구성(Storage Organization)
- 실행하는 모든 프로그램은 메모리에 연결되어 있습니다.
- 메모리는 아래 설명과 같이 세 부분으로 나뉩니다.
- 기억 영역의 구성은 메모리 위치에 값을 바인딩하는 절차입니다.
- 정적 세그먼트(Static Segment)
  - 정적 기억영역은 두 부분으로 나뉩니다.
  - 코드 세그먼트(Code segment)
    - 이 부분에는 프로그램 코드가 저장되고 프로그램이 실행되는 동안 변경되지 않습니다.
    - 일반적으로 이 부분은 읽기 전용으로 생성되고 보호됩니다.
    - 상수는 자신의 형(type)에 따라 정적 영역에 배치될 수도 있습니다.
  - 데이터 세그먼트(Data segment)
    - 간단히 전역 데이터(global data)를 저장하는 부분입니다.
    - 이 부분에는(코드를 제외한) 프로그램 정적 데이터가 저장됩니다.
    - 보통, 이 구역은 수정이 가능합니다(전역 변수와 정적 변수가 여기에 포함됩니다).
    - 이 영역은 다음을 포함합니다.
      - 전역 변수(Global Variables)
      - 숫자와 문자열 값이 지정된 상수 리터럴
      - 호출 사이에 값이 유지되는 지역 변수(예, 내부 정적 변수)
  - 스택 세그먼트(Stack Segment)
    - 프로그램 언어가 재귀를 지원한다면 존재할 수 있는 변수의 수는 이론상 제한이 없습니다. 이런 경우 정적 할당은 무의미합니다.
    - 이런 문제를 해결하기 위해 스택 할당이 사용됩니다.
    - 우리가 함수를 호출할 때, 스택(run-time stack) 내에 함수에 대한 새로운 활성 레코드(프레임이라고도 함)를 밀어 넣습니다.
    - 각각의 프레임은 스택 안에 많은 연속된 바이트를 사용하며 고정된 크기가 아닐 수 있습니다.
    - 피호출자 함수가 호출자 함수에 제어를 반환할 때, 피호출자 함수의 활성 레코드들은 스택에서 제거(pop)됩니다.
    - 일반적으로 활성 레코드들은 다음과 같은 정보를 가지고 있습니다.
      - 지역 변수(Local Variables)
      - 형식 매개 변수(Formal parameters)
      - 활성화를 위해 필요한 추가적인 정보
      - 임시 변수들(Temporary variables)
      - 반환 주소(return address)
  - 힙 세그먼트(Heap Segment)
    - 임시로 사용하는 메모리 공간을 동적으로 늘리고자 할 경우(C언어에서는 포인터를 통해), 정적 혹은 스택 할당은 적절하지 않은 방법입니다.
    - 이러한 요구를 처리하기 위해 별도의 할당 방식이 필요합니다.
    - 이때 '힙 할당 전략(Heap allocation strategy)'을 사용합니다.
    - 힙 할당 방법은 연결된 데이터 구조의 요소가 동적으로 할당되고 객체의 크기를 동적으로 조정해야 할 때 필요합니다.
    - 힙은 동적으로 할당되는 메모리 영역입니다.
    - 또 스택처럼 프로그램 실행 중에 늘어나거나 줄어들 수도 있지만 스택과 달리 LIFO(Last In First Out) 방식이 아니며 관리하기가 훨씬 복잡합니다.
    - 일반적으로 모든 프로그래밍 언어는 스택과 힙 할당을 사용하도록 구현하고 있습니다.
    - 어떻게 두 가지 메모리 할당방법 모두를 할 수 있을까요? 한 가지 간단한 접근 방법은 프로그램 시작시에 사용 가능한 메모리를 스택과 힙, 두 개의 영역으로 분리하는 것입니다.
    - 암묵적인 힙 할당
      - 할당은 자동적으로 수행됩니다. 예를 들어 java 혹은 C#과 같은 언어에서 인스턴스들은 힙에 위치합니다.
      - 스크립트 언어와 함수 언어들은 객체들을 저장하는데 힙을 광범위하게 사용합니다.
    - 명시적인 힙 할당
      - 이 방식은 시스템에 힙에 메모리 할당을 하도록 명시적으로 알려주어야 하며 다음과 같은 경우가 포함됩니다.
        - 할당 혹은 할당 해제를 위한 구문 및 함수
        - malloc/free, new/delete
  - 단편화(Fragmentations)
    - 가끔 조그마한 메모리 블록들이 어떤 프로세스에도 할당되지 않고 낭비됩니다.
    - 기본적으로 단편화는 아래 두 가지 유형이 있습니다.
    - 내부 힙 단편화(internal heap fragmentation)
      - 객체를 유지하기 위한 크기보다 큰 크기의 블록이 할당되고 여분의 공간이 사용되지 않을 경우
    - 외부 힙 단편화(external heap fragmentation)
      - 이 경우는 사용되지 않는 공간이 여러 블록들로 존재하고, 이들 중 어떤 블록도 이후 요청에 필요한 만큼 크지 않을 경우입니다.
      - 즉, 충분한 크기가 되지 않아 사용되지 않는 작은 블록들이 여기저기 여러 조각으로 나뉘어 있는 것을 말합니다.
  - 힙 할당 알고리즘(Heap Allocation Algorithms)
    - 일반적으로 사용하지 않는 힙 블록들의 연결 리스트가 유지되고 요청이 들어오면 아래 기법 중 한 가지로 메모리를 할당합니다.
      - 최초 적합(First-fit): 리스트에서 요청된 크기를 충분히 만족하는 첫 번째 블록을 선택합니다.
      - 최적합(Best-fit): 리스트에서 요청된 크기에 충분한 가장 작은 공간을 찾아 선택합니다.
    - 객체가 선택된 블록보다 작을 때, 여분의 공간은 사용하지 않은 블록으로 리스트에 추가됩니다.
    - 사용된 블록이 해지(free)될 때 인근의 사용하지 않은 블록들과 병합됩니다.


### 1.12 프로그래밍 테크닉
- 비구조적 프로그래밍(Unstructured programming)
  - 보통 처음 프로그램을 만드는 사람들은 단순히 하나의 메인으로 구성된 프로그램을 작성합니다.
  - 이것은 일단 프로그램의 크기가 커졌을 때 문제가 됩니다.
  - 예를 들어 프로그램 내의 서로 다른 곳에서 동일한 절차를 가진 문장이 사용된다면 해당 문장을 복사해서 붙여 넣어 사용해야 합니다.

- 절차적 프로그래밍(Procedural programming)
  - 이 방식은 한군데 동일한 절차를 가진 문장을 조합하여 사용합니다.
  - 이런 프로시저 호출은 프로시저를 실행(procedure invoke)하고 절차가 완료된 후 제어의 흐름은 곧바로 호출된 지점 다음에서 진행됩니다.
  - 앞에서 다룬 매개 변수를 활용한 절차적 프로그램은 더욱 구조화되고 에러 없이 작성될 수 있습니다.

- 모듈러 프로그래밍(Modular programming)
  - 모듈러 프로그래밍은 분할된 모듈에 공통적인 기능들을 함께 모아놓고 사용합니다.
  - 전체 프로그램을 프로시저 호출로 상호 작용하는 몇 개의 작은 부품으로 분할합니다.
  - 각각의 모듈은 자체적인 데이터를 가질 수 있습니다.

- 객체지향 프로그래밍(Object-oriented-programming)
  - 로직과 함수 대신 객체와 데이터로 구성된 프로그래밍 언어 모델입니다.
  - 객체지향 프로그래밍은 문제를 다루기 위해 필요한 로직이 아닌 객체로 바라봅니다.
  - OOP에서는 제일 먼저, 다루고자 하는 모든 객체들과 이들이 서로 어떤 관계인지를 식별합니다(이를 데이터 모델링이라고 합니다).
  - 일단 식별된 객체는 해당 객체의 클래스와 클래스가 가지는 데이터의 정의 그리고 이들을 다룰 수 있는 모든 함수로 일반화합니다.



### 1.13 프로그래밍 기초 문제

문제 1. 네임 맹글링(Name mangling)이란 무엇입니까?
답
- C 컴파일러는 밑줄('_')을 덧붙여 함수나 심볼(symbol)을 연결합니다.
- 예를 들어 main() 함수는 _main() 이라는 심볼명에, 변수 counter(int counter;)는 _counter라는 심볼명에 링크됩니다.
- C++ 컴파일러는 이와 같은 방식으로 동작하지 않습니다.
- C++은 함수 오버로딩 메커니즘이 있습니다.*
  * Ada, C++, C#, D, Java와 같은 언어들에서 제공하고 있는 기능으로 동일한 함수명에 대해 여러 가지 의미를 가질 수 있는 것을 말하며 '다중 정의'라고 부릅니다. 동일한 함수명으로 형식 파라미터의 개수 또는 자료형, 함수의 되돌림 값의 자료형에 따라 다른 의미를 정의합니다.
- C++이 함수의 심볼과 연결되기 전에 단지 밑줄로 함수 심볼을 만들어 연결한다면 함수 오버로딩을 제공할 수 없게 됩니다.
- 예를 들어 text() 함수와 이를 오버로딩한 함수가 다음과 같이 있다고 가정해 봅시다.
```
int test(int a, int b)
int test(int a, int b, int c)
```
- 이제 C++이 _test()를 심볼명으로 사용한다면 오버로딩한 두 함수는 여기에 연결될 수 없게 됩니다.
- 이를 해결하기 위해, C++ 링커(linker)는 '맹글링'이라는 것을 사용합니다.
- 네임 맹글링은 C++ 컴파일러가 동일한 이름의 함수와 변수들을 라인 식별자, 인자 크기 등의 확장된 정보들을 가진 어떤 명칭(유일 심볼명)으로 변경하고 여기에 유일 심볼명에 연결하기 위한 메커니즘입니다.
- 함수명 맹글링(function name mangling)은 <function index><function name>@<argument size>와 같은 방식으로 수행되고 변수명 맹글링(variable name mangling)은 <variable name> @@<UNIQUE ID>와 같은 형태로 수행됩니다.
- 예를 들면, int test(int a, int b)는 _ladd@8에 연결되고 int test(int a, int b, int c)는 _2add@12에 연결됩니다.
  

문제 2. C++과 Java의 닮은 점과 차이점은 무엇입니까?
- Java는 typedef, enum, defined 또는 preprocessor를 지원하지 않습니다. Java는 클래스를 지원하지만 구조체(structure)와 유니온(union)을 지원하지 않습니다.
- 모든 C++ 프로그램은 main 함수가 필요합니다.
- 모든 자바 클래스는 Object 클래스를 상속해야 합니다.
- Java에서 선언하는 모든 함수 혹은 메소드는 클래스 선언 내에 포함됩니다.
- C++과 Java 모두 클래스의 객체를 인스턴스화하지 않아도 호출할 수 있는 클래스(static) 메소드나 함수를 지원합니다.
- Java에서 'interface' 키어드는 함수에 대한 선언과 상수만을 가지는 ABC(Abstract Base Classes)와 동등한 효과를 내기 위해 사용합니다(Java에서는 실질적인 ABC를 만들 수도 있습니다). 멤버 함수와 변수는 정의되어서는 안됩니다. 이 'interface' 개념은 C++에서는 지원하지 않습니다.
- Java는 다중 상속을 지원하지 않습니다. Java 프로그램에서 interface 기능은 어느 정도 기본적인 문제 없이 다중 상속의 주요 기능을 제공합니다.
- Java는 자동 형 변환을 지원하지 않습니다.
- C++과 달리 Java는 배열이 얼마나 큰지 알려주는 length 멤버 변수를 가진 객체로 배열을 제공합니다. 배열의 범위를 넘어서 접근하면 예외를 발생시킵니다.
- Java는 포인터를 지원하지 않습니다(적어도 포인터 내 주소 변경이나 포인터 연산을 수행할 수 없습니다). 포인터에 대한 대부분의 필요성은 배열(Array)과 문자열(String) 형을 제공하여 제거되었습니다. 예를 들어 C++에서 흔히 사용되는 문자열의 첫 번째 문자를 가리키는 char* ptr 선언과 문자열의 끝을 가리키는 종료 문자열(null-terminated string)이 Java에서는 문자열 자체가 객체이기 때문에 필요하지 않습니다.
- C++에서는 스코프 해석 연산자(::)가 필요하지만 Java에서는 사용하지 않습니다. Java에서 '.'(도트)은 전체 참조 경로를 구성하는데 사용됩니다. 또한 포인터가 없으므로 C++에서 사용되는 포인터 연산자(->)은 Java에서 필요하지 않습니다.
- C++에서는 정적 멤버와 함수들이 클래스의 이름과 스코프 해석 연산자로 연결한 정적 멤버 이름을 사용하여 호출됩니다. Java에서는 이와 같은 목적으로 '.'을 사용합니다.
- C++처럼 Java는 int, float 등과 같은 원시 자료형을 가지고 있습니다. C++과 달리, 원시 자료형의 크기는 플랫폼과 상관없이 동일합니다. Java에서는 unsigned integer 형이 없습니다. 유형 검사 및 유형 요구 사항은 C++에 비해 Java에서 훨씬 엄격합니다.
- C++과 달리 Java는 실질적인 boolean 형을 제공합니다.
- Java에서 조건문은 C++처럼 정수로 표현하기 보다 boolean으로 판단해야 합니다. "if(x+y)..."와 같은 조건문은 boolean으로 평가되지 않기 때문에 Java에서는 허용되지 않습니다.
- C++에서 문자형(char type)은 ASCII(혹은 확장된 ASCII) 문자 집합에 연결된 1 바이트(8 bit)입니다. Java에서 문자형은 2바이트(16 bit)입니다.
- C++은 모든 유형의 객체 혹은 변수를 정적 메모리의 경우 컴파일 시에 동적 메모리의 경우 실행 시에 인스턴스화 할 수 있습니다. 하지만 Java의 모든 원시 자료형은 컴파일 시 인스턴스화되어야 하며 모든 객체는 실행시 동적 메모리에 인스턴스화 되어야 합니다. 실행 시 동적 메모리에 객체를 인스턴스화 할 수 있도록 byte와 short를 제외한 모든 원시 자료형에 대한 래퍼 클래스(Wrapper class)들이 제공됩니다.
- C++에서 명확하게 초기화하지 않는 경우 원시 자료형의 변수들은 쓰레기(garbage) 값을 가지게 됩니다. 비록 원시 자료형의 지역 변수들이 선언 시 초기화될 수 있다고는 하지만, 클래스의 원시 데이터 멤버들을 클래스 정의 시 초기화될 수 없습니다.
- Java에서 원시 데이터 멤버들을 클래스 정의 시 초기화할 수 있으며, 생성자에서 초기화할 수도 있습니다. 초기화에 실패할 경우 이들은 0(혹은 그와 동등한) 값으로 초기화될 것입니다.
- C++처럼 Java는 다중 정의(overloading)할 수 있는 생성자를 지원합니다. C++에서와 같이 생성자를 제공하지 않을 경우 기본 생성자를 제공하고 있습니다. 여러분이 생성자를 제공한다면 기본 생성자는 자동으로 무시됩니다.
- Java에서 모든 객체는 해당 생성자가 복사되는 것을 방지하기 위해 참조에 의한 전달을 합니다.(실제 Java에서 모든 매개 변수는 값에 의해 전달됩니다. 참조변수를 복사해서 전달함으로써 수신 함수의 코드에서 변수에 의해 참조되고 있는 객체에 접근할 수 있으며, 해당 객체의 내용을 변경할 수 있습니다. 그러나 수신 함수의 코드에서 원래 참조 변수가 다른 객체를 참조하도록 할 수는 없습니다).
- Java에서는 소멸자가 없습니다. 사용되지 않는 메모리는 메인 프로그램과 다른 스레드에서 실행하는 가비지 콜렉터(garbage collector)에 의해 운영체제로 반환됩니다. 이것이 Java와 C++ 사이에서 크고 미묘하며 매우 중요한 수많은 차이점을 유발합니다.
- C++과 마찬가지로 Java도 함수의 다중 정의를 지원합니다. 그러나 기본(default) 인자는 제공하지 않습니다.
- C++과 달리 Java는 템플릿(template)을 지원하지 않습니다. 따라서 제네릭(generic) 함수 또는 클래스도 없습니다.
- C++과 달리 몇몇 자료 구조 클래스들이 Java의 표준 버전에 포함되어 있습니다.
- 멀티 쓰레딩은 Java 언어의 표준 기능입니다.
- 비록 Java가 접근제어를 위해 C++과 같은 키워드('private', 'public' 그리고 'protected')를 사용하더라도, 이 키워드들에 대한 해석은 Java와 C++ 사이에 상당한 차이가 있습니다.
- Java에서는 'virtual' 키워드가 없습니다. 정적이 아닌 모든 함수는 언제나 동적 바인딩을 사용합니다. 따라서 C++에서 사용되는 것과 같은 목적으로 virtual 키워드가 필요하지 않습니다.
- Java는 함수가 다중 정의될 수 없으며 정적으로 바인딩될 수 있다고 정의할 때 사용되는 'final'이라는 키워드를 제공합니다(이 경우 컴파일러가 인라인(inline)으로 만들 수 있습니다).
- 예외처리(exception handling) 시스템의 상세한 구현은 C++의 그것과 크게 다릅니다.
- C++과 달리 Java는 연산자 다중 정의를 지원하지 않습니다. 그러나 (+)와 (+=) 연산자는 문자열들을 연결하는 과정에서 다른 형들을 문자열로 전환하도록 자동으로 다중 정의 됩니다.
- C++과 같이 Java 어플리케이션은 다른 언어로 작성된 함수를 호출할 수 있습니다. 이것을 일반적으로 네이티브 메소드(native method)라고 합니다. 그러나 애플릿은 네이티브 메소드를 호출할 수 없습니다.
  

문제 3. 옅은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점은 무엇입니까?
- 객체의 옅은 복사는 모든 멤버 필드 값들을 복사합니다.
- 필드 자체가 값인 경우는 잘 동작하지만 동적으로 할당된 메모리를 가리키는 포인터일 경우 그렇지 않을 수 있습니다.
- 포인터는 복사되지만 포인터가 가리키는 메모리는 복사되지 않기 때문에 원래 필드의 객체와 복사본 둘다 동적으로 할당된 동일한 메모리를 가리키게 됩니다.
- C++에서 디폴트 복사 생성자와 할당 연산자는 모두 옅은 복사를 합니다.
- 깊은 복사는 모든 필드와 필드가 가리키는 동적으로 할당된 메모리를 복사합니다.
- 깊은 복사를 하기 위해서는 복사 생성자를 작성하고 할당 연산자를 다중 정의하지 않으면 복사본은 원본을 가리키게 됩니다.

문제 4. C++에서 객체 잘림(object slicing)이란 무엇입니까?
- 객체지향 프로그래밍에서 파생 클래스는 베이스 클래스에 추가적인 멤버 변수들을 정의하여 확장한 클래스입니다.
- 파생 클래스를 베이스 클래스에 할당하면 베이스 클래스에 해당하는 값들은 복사되지만 확장된 값들은 저장할 곳이 없어 복사되지 않습니다.
- 이를 개체 잘림이라고 합니다. 즉 베이스 클래스 객체는 단지 베이스 클래스의 멤버에게만 접근할 수 있습니다.
- 또 베이스 클래스의 멤버들과 파생 클래스의 멤버 사이에 분리가 일어난다는 말입니다.
```
class base {
  public:
    int i, j;
};

class derived: public base {
  public:
    int k;
};
  
int main() {
  base b;
  derived d;
  b = d;
  return 0;
}
- 이 코드에서 b는 멤버 변수로 i와 j를 가지고 있는 반면, d는 i, j 그리고 k를 가지고 있습니다.
- b에 d를 할당할 때 d의 i와 j만이 b의 i와 j로 복사되고 k는 복사되지 않습니다.
- 이 영향으로 객체 d는 잘림이 발생하게 됩니다.
```
  
문제 5. C++에서 가상 함수(virtual function)를 설명하세요
- 함수 호출이 일어나면 C++은 컴파일 시 함수 호출에 맞는 함수 정의를 연결합니다.
- 이것을 정적 바인딩이라고 부릅니다.
- 컴파일러는 실행 시 함수 호출과 알맞은 함수 정의를 연결하도록 정의할 수 있는데, 이를 동적 바인딩이라고 합니다.
- 특정 함수에 대해 동적 바인딩을 사용하고자 할 때 'virtual'이라는 키워드를 사용합니다.
  
```
- 정적 바인딩 예시
class A {
  void f() {
    cout << "Base class A" << endl;
  }  
};
  
class B: A {
  void f() {
    cout << "Derived Class B" << endl;
  }
};

void g(A& arg) {
  arg.f();  
}
  
int main() {
  B x;
  g(x);
}

=> 출력 결과: Class A
- 함수 g()가 호출되면 인자가 B의 인스턴스에 대한 참조자라 해도 A::f()가 호출됩니다.
- 컴파일 시,컴파일러는 g() 함수의 인자가 A로부터 파생된 객체에 대한 참조여야 한다는 것만을 알고 있을 뿐 인자가 A의 인스턴스에 대한 참조인지 B의 인스턴스에 대한 참조인지를 알 수 없습니다.
- 그러나 실행 시점에는 알 수 있습니다.
```
  
```
class A {
  virtual void f() {
    cout << "Base class A" << endl;
  }  
};
  
class B: A {
  void f() {
    cout << "Derived Class B" << endl;
  }
};

void g(A& arg) {
  arg.f();  
}
  
int main() {
  B x;
  g(x);
}
=> 출력 결과: Class B
```
  
문제 6. 추상 클래스와 인터페이스란 무엇이며 둘의 차이점은 무엇입니까?
- 추상 클래스는 인스턴스화될 수 없으며 일반적으로 하나 이상의 순수 가상 함수를 가지는 클래스로 구현됩니다.
- 순수 가상 함수는 모든 파생된 구상 클래스(concrete class)에서 구체적인 동작이 정의되어야 하는 함수의 선언으로 멤버 함수에 "=0"과 함께 선언하여 표시합니다.

```
class AbstractionClass {
public:
  virtual void AbstractMemberFunction() = 0;
  // 순수 가상 함수가 이 클래스를 추상 클래스로 만듭니다.
  virtual void NonAbstractVirtualMemberFunction();
  // 가상 함수
  void NonAbstractMemberFunction();
};
```
- 일반적으로 추상 클래스는 구현해야 할 것들을 정하고 구상 클래스에서 이를 상속하기 위해 사용됩니다.
- 클래스가 순수 가상 함수만을 가지고 있을 경우 이를 순수 추상 클래스 혹은 인터페이스라고 부릅니다.
- C++에서 인터페이스의 개념은 순수 추상 클래스에 상응하며 Java에서와 같이 'interface'라는 키워드를 사용하지 않습니다.
- 즉, Java에서는 아래 코드와 같이 'interface'라는 키워드를 사용하여 순수 추상 클래스를 정의할 수 있습니다.
  
```
interface InterfaceClass {
  void function1 (int value);
  void function2 (int newValue);
  void function3 (int someValue);
}
```
- 객체지향 프로그래밍에서 가상 함수는 동작의 다형성을 제공하기 위해 상속된 클래스에서 동일한 특징(함수의 이름, 인자의 개수, 인자의 형, 반환 값)을 사용하여 오버라이드할 수 있는 함수를 말합니다.
- 따라서 정의에 따른다면 Java에서 final과 private을 제외한 static 메소드가 아닌 모든 메소드는 기본적으로 가상 메소드입니다.
- 동작의 다형성을 상속할 수 없는 메소드들은 가상 메소드가 아닙니다.
- 설계 시에는 파생 클래스에 대한 인터페이스만을 나타낼 수 있는 베이스 클래스가 필요합니다.
- 베이스 클래스는 실제로 인스턴스화하지 않습니다.
- 상위 형으로 형 변환을 위한 인터페이스로 사용할 뿐입니다.
- Java에서는 abstract 키워드를 사용하여 추상 클래스를 만들 수 있습니다. 만일 추상 클래스를 인스턴스화 하고자 한다면 컴파일러가 이를 막을 것입니다.
- 추상 클래스는 실행 메소드와 추상 메소드를 가질 수 있으며, 하나의 추상 클래스에 대한 하위 클래스일 수 있습니다.
- interface 키워드는 모든 함수 혹은 메소드의 구현을 방지함으로써 한층 더한 추상 클래스 개념을 취합니다.
- 함수 혹은 메소드를 선언할 수 있으나 구현할 수 없습니다.
- 인터페이스의 구현은 클래스에서 해야 합니다.
- 인터페이스에서 모든 함수는 추상 함수입니다.
- 하나의 클래스는 여러 인터페이스를 구현할 수 있습니다.
- Java에서 추상 클래스와 인터페이스 클래스의 차이점은 다음과 같습니다.
  - 핵심적인 차이는 Java 인터페이스의 메소드들은 무조건 추상 메소드며 구현부를 가질 수 없습니다. Java의 추상 클래스는 기본(default) 동작을 구현한 인스턴스 메소드를 가질 수 있습니다.
  - Java 인터페이스에서 변수는 기본적으로 final로 선언됩니다. 추상 클래스는 final이 아닌 변수를 포함할 수 있습니다.
  - Java 인터페이스의 멤버들은 기본적으로 public입니다. Java 추상 클래스는 private, protected 등과 같은 클래스의 멤버들의 일반적인 유형을 가질 수 있습니다.
  - Java 인터페이스는 'implements'라는 키워드를 사용하여 구현되어야 하고 Java 추상 클래스는 extends 키워드를 사용하여 확장되어야 합니다.
  - Java 인터페이스는 다른 인터페이스 만을 확장할 수 있으며, 추상 클래스는 다른 Java 클래스를 확장하고 여러 인터페이스를 구현할 수 있습니다.
  - Java 클래스는 여러 인터페이스를 구현할 수 있지만 하나의 추상 클래스만 확장할 수 있습니다.
  - 인터페이스는 무조건 추상이고 인스턴스를 만들 수 없습니다. Java 추상 클래스도 인터페이스를 만들 수 없는 것은 마찬가지지만 main()이 존재한다면 실행시킬 수 있습니다.
  
  
문제 7. C++에서의 가상 테이블(virtual tables)을 설명하세요.
- 가상 함수들을 구현하기 위해서 C++은 가상 테이블이라는 늦은 바인딩의 특별한 형식을 사용합니다.
- 가상 테이블은 동적 혹은 늦은 바인딩 방식으로 호출되는 함수를 조회하는 테이블입니다.
- 가상 테이블은 vtable, virtual function table 또는 virtual method table이라 부르기도 합니다.
- 가상 테이블이란 말을 설명하자면 약간 복잡하지만 실제로는 매우 간단합니다. 먼저 모든 가상 함수(virtual function)을 사용하는 클래스들에게 자신만의 가상 테이블이 주어집니다.
- 이 테이블은 단순히 컴파일러가 컴파일 시 만드는 정적 배열입니다. 가상 테이블은 클래스의 객체에 의해 호출될 수 있는 가상 함수 하나당 하나의 항목을 가집니다.
- 가상 테이블의 항목들은 해당 클래스에서 접근 가능한 함수를 가리키는 단순한 함수 포인터입니다.
- 두 번째로, 컴파일러는 베이스 클래스에 *_vptr이라는 숨겨진 포인터를 추가합니다.
- *_vptr은 해당 클래스의 가상 테이블을 가리키도록 클래스의 인스턴스가 생성될 때(자동으로) 설정됩니다.
- 실제로 컴파일러에 의해 자기 참조를 해결하기 위해 함수의 매개 변수로 사용되는 *this 포인터와 달리 *_vptr은 실제 포인터입니다.
- 즉, 각 클래스의 객체는 이 포인터 크기만큼 더 크게 할당되며, *_vptr은 파생 클래스에 의해 상속된다는 것입니다.
- 가상 테이블을 이용하여 컴파일러와 프로그램은 기본 클래스의 포인터만을 사용하더라도 함수의 호출을 알맞은 가상 함수에 연결할 수 있게 됩니다.
  

문제 8. Java에서 ArrayList와 Vector의 차이점은 무엇입니까?
- Java에서 배열은 ArrayList 또는 Vector를 사용하는 것보다 빠르며, 배열의 크기를 예측할 수 있는 경우에 좋습니다(배열은 List처럼 크기를 늘일 수 없습니다).
- ArrayList 또는 Vector는 add(...), remove(...) 등 같이 몇몇 편리한 메소드와 함께 내부적으로 배열을 사용하는 특화된 자료구조 입니다.
- 또한 ArrayList는 IndexOf(Object obj) 그리고 lastIndexOf(Object obj) 함수로 인덱스 기반의 검색을 지원합니다.
  
  
문제 9. Java에서 HashMap이 어떻게 동작하는지 설명하세요.
- HashMap은 해시 원리로 작동하며 put(), get() 메소드를 가지고 HashMap에 데이터를 저장하거나 조회합니다.
- 객체를 HashMap에 저장하기 위해 put() 메소드를 전달할 때, HashMap은 내부적으로 키 값으로 주어진 객체의 hashcode() 메소드를 호출하고 자신의 해싱 함수에 해당 해시 코드를 적용하여 값 객체를 저장하기 위한 버킷(bucket)위치를 식별합니다.
- 여기서 중요한 것은 HashMap이 key와 value를 모두 버킷에 저장한다는 것입니다. 이것은 HashMap의 조회 로직을 이해하기 위한 필수적인 사항이며, 이 사항을 이해하지 못하고 단지 버킷에 값을 저장한다고 가정한다면 HashMap에 저장된 객체를 조회하는 로직을 알지 못하는 것입니다.

- 두 개의 서로 다른 객체가 동일한 해시코드를 가진다면 어떤 일이 발생할까?
- 종종 면접관이 해시 코드가 같으면 동일한 객체이고 이미 저장된 동일한 객체를 다시 저장하고자 한다면 HashMap은 예외를 던지거나 이 값을 다시 저장하지 않는다는 등의 이야기를 할 것입니다. 그럴때면 Java에서 서로 다른 객체가 동일한 해시 코드를 가질 수 있다는 equals()와 hashCode() contract를 상기시켜 주십시오.
- 더 나아가 "hashCode()가 같기 때문에 버킷의 위치가 같을 것이고, 이 경우 HashMap에서 충돌이 발생합니다.
- 충돌을 해결하기 위해 버킷에 값을 저장하는데 연결 리스트를 사용하며 저장할 값 객체는 연결 리스트의 다음 노드(node)에 저장됩니다."라고 말할 수도 있을 것입니다.

- 만일 서로 다른 객체의 해시 코드가 동일할 경우 어떻게 조회할까요?
- 버킷의 위치를 찾은 후, 버킷 내 연결 리스트에서 정확히 동일한 노드를 찾기 위해 keys.equals() 메소드를 호출하고 Java의 HashMap에서 해당 키에 연결된 값 객체를 반환합니다.
  
- HashMap의 크기가 적재 인수(load factor)에 의해 정의된 크기보다 더 많은 객체를 담으면 Java의 HashMap에서 어떤 일이 일어날까요?
- HashMap이 어떻게 동작하는지 정확히 알기 전까지 이 질문에 답할 수 없을 것입니다.
- HashMap의 크기가 적재 인수에 의해 정의된 임계점을 초과하면 HashMap의 크기를 조정합니다.
- 예를 들면, 적재 인수가 0.75일 때 HashMap이 75%까지 채워지면 맵의 크기를 재조정하게 됩니다.
- Java의 HashMap은 이전의 HashMap 크기의 두 배 크기의 또 다른 새로운 버킷 배열을 생성한 후 여기에 이전의 모든 요소들을 밀어 넣습니다.
- 또한 새로운 버킷의 위치를 찾기 위해 해시 함수를 적용하기 때문에 이 과정과 절차를 rehashing이라고 부릅니다.
  

문제 10. Java에서 HashMap과 HashTable의 차이점은 무엇입니까?
1. HashMap 클래스는 비동기면서 null이 허용된다는 것을 제외하면 HashTable과 거의 비슷합니다(HashMap은 키와 값에 null을 허용하지만 HashTable은 null을 허용하지 않습니다)
2. HashMap은 맵의 순서가 시간이 지나도 일정하게 유지된다고 보장할 수 없습니다.
3. HashMap은 비동기인 반면 Hash Table은 동기입니다.
4. HashMap 내 Iterator는 fail-fast로, 다른 스레드가 Iterator 자체의 remove() 메소드를 제외하고 맵에 항목을 추가하거나 제거하여 구조적으로 변경하면 ConcurrentModificationException을 던지지만 HashTable의 enumerator는 그렇지 않습니다. 그러나 이것은 항상 보장된 동작은 아니며, JVM에 의해 최선책으로 수행됩니다.
  
  
  
문제 11. Java에서 스레드와 동기화 동작을 설명하세요
- Java는 프로그램 실행을 완료하기 위해 여러 스레드를 동시에 실행하는 다중 스레드 언어이므로 동기화는 중요한 개념입니다.
- Java에서 동기화는 'synchronized', 'volatile'이라는 키워드를 사용하여 구현합니다.
- 요약하자면 Java의 synchronized 키워드는 '동시 프로그램 작성(concurrent programming)'을 위한 다음 핵심 기능을 제공합니다.
  - Java에서 synchronized 키워드는 공유 자원의 상호 배타적인 접근을 보장하고 데이터 경합(data race)을 방지하는 잠금(locking)을 제공합니다.
  - 또한, synchronized 키워드는 synchronized 혹은 volatile 키워드를 사용하지 않을 경우 미묘한 동시처리(concurrent) 문제를 초래할 수 있는 컴파일러에 의한 코드 재배열(reordering)을 방지합니다.
  - synchronized 키워드는 잠금(locking)과 잠금 풀기(unlocking)를 수반합니다. 스레드는 synchronized 메소드 또는 블록에 진입하기 전에 잠금을 획득해야 합니다.
  - 이때 캐시가 아닌 메인 메모리에서 데이터를 읽고 잠금을 해지할 때 메모리 불일치 오류를 제거하기 위해 메인 메모리 쓰기 작업을 합니다.
  
- 자바에서Synchronized 키워드: 
  - Java에서 synchronized 블록에 작성된 코드는 상호 배타적이며 한번에 한 스레드에 의해서만 실행될 수 있습니다.
  - Java에서는 정적 synchronized 메소드와 비정적 synchronized 메소드 그리고 synchronized 블록을 가질 수 있지만 synchronized 변수는 가질 수 없습니다.
  - synchronized 키워드를 사용한 변수는 잘못된 것으로 컴파일 에러가 발생합니다.
  - Java는 synchronized 변수 대신 volatile 변수를 제공합니다.
  - 이는 volatile 선언된 변수를 메인 메모리에서 읽어와 로컬에 캐시하지 않도록 JVM 스레드에 지시합니다.
  - Java에서 함수 전체 대신 코드의 핵심 영역만 잠글 수 있기 때문에 메소드 동기화보다는 블록 동기화가 선호됩니다.
  - Java 동기화는 성능 문제를 동반하기 때문에 반드시 동기화가 필요한 부분만을 synchronized 키워드로 묶어 사용해야 합니다.

- synchronized 메소드 예제:
  - synchronized 키워드를 메소드에 사용하는 방법은 단순히 메소드 앞에 synchronized 키워드를 적용하면 됩니다.
  - 단지 주의할 점은 정적 synchronized 메소드는 클래스 객체를 잠그며 비정적 메소드는 현재 객체(this)를 잠근다는 것입니다.
  - 따라서 Java의 정적 혹은 비정적 메소드는 병렬 실행이 가능합니다.
  - 이것은 네이티브 개발자가 Java의 synchronized 코드를 작성할 때 겪는 공통적인 실수입니다.
  
```
public Class Counter {
  private static int count = 0;
  public static synchronized int getCount() {
    return count;
  }
  public synchronized setCount (int count) {
    this.count = count;
  }
}
- 위 Java 동기화 코드 예제는 getCount()와 setCount() 메소드가 동일한 객체의 잠금을 획득하지 않아 병렬 실행으로 잘못된 count를 획득할 수 있기 때문에 제대로 동기화되지 않습니다.
- 예제에서 getCount() 메소드는 Counter.class를 잠그는 반면 setCount() 메소드는 현재 객체(this)를 잠글 것입니다.
- 이 코드를 제대로 동기화하고 싶다면 두 메소드 모두 정적 혹은 비정적이어야 하거나 synchronized 메소드가 아닌 synchronized 블록을 사용해야 합니다.
```
  
- synchronized 블록 예제
  - synchronized 블록 사용은 synchronized 메소드의 사용과 매우 유사합니다.
  - 여기서 중요한 것은 코드의 synchronized 블록을 잠그기 위해 객체가 사용되면 예제에서 Singleton.class는 null일 때 synchronized 블록은 NullPointerException을 던질 것입니다.
  
```
public class Singleton {
  private static volatile Singleton _instance;
  public static Singleton getInstance() {
    if(_instance == null) {
      synchronized(Singleton.class) {
        if(_instance == null)
        _instance = new Singleton();
      }
    }
    return _instance;
  }
}
- 예제는 싱글톤(Singleton) 패턴에서 "double checked locking"의 오래된 예입니다
- 이 예에서 만일 전체 메소드를 동기화한다면 이 메소드를 호출할 때 마다 잠기지만, 실제로는 처음 인스턴스를 생성할 때만 잠금이 필요하기 때문에 핵심적인 영역만 동기화하여 일부 성능을 개선하였습니다.
```

synchronized 키워드의 중요 사항
  1. Synchronized 키워드는 Java의 멀티스레드 환경에서 공유되는 리소스에 대한 상호 배타적인 접근을 제공하기 위해 사용됩니다. Java에서 동기화는 두 개의 스레드가 동시에 동일한 잠금이 필요한 동기화된 메소드를 실행하지 않도록 한다는 것을 보장합니다.
  2. Synchronized 키워드는 메소드 혹은 블록에만 사용할 수 있습니다.
  3. 스레드가 synchronized 메소드 또는 블록에 진입할 때마다 잠금을 획득하고 synchronized 메소드 혹은 블록을 빠져나갈 때마다 잠금을 해제합니다. synchronized 메소드가 완료되거나 에러 혹은 예외가 발생하여 빠져나가더라도 잠금은 해지됩니다.
  4. Java 스레드는 인스턴스 synchronized 메소드에 진입할 때 객체(object) 레벨의 잠금을 획득하고 정적 synchronized 메소드에 진입할 때 클래스 레벨의 잠금을 획득합니다.
  5. Java의 synchronized 키워드는 재진입 속성을 가지고 있습니다. 이는 synchronized 메소드가 동일한 잠금이 필요한 다른 synchronized 메소드를 호출하면 잠금을 가진 현재 스레드가 새로운 잠금을 획득할 필요 없이 해당 메소드로 진입할 수 있음을 의미합니다.
  6. synchronized 블록에서 사용된 객체가 null일 경우 동기화는 NullPointerException을 던질 것입니다. 예를 들어 synchronized(myInstance)에서 myInstance가 null일 경우 NullPointException을 던질 것입니다.
  7. Java synchronized 키워드의 주요 단점은 java.util.concurrent.locks.ReentrantLock을 사용하여 구현할 수 있는 동시 읽기(concurrent read)를 허용하지 않는다는 것입니다.
  8. Java synchronized 키워드의 한 가지 제약 사항은 동일한 JVM 내 공유되는 객체의 접근 제어에만 사용할 수 있다는 것입니다. 하나 이상의 JVM에서 공유되는 파일 시스템 혹은 데이터베이스의 동기화된 접근이 필요하다면 Java synchronized 키워드는 전혀 쓸모가 없으며, 이를 위한 포괄적인 잠금 유형을 구현해야 합니다.
  9. synchronized 키워드는 성능 비용 저하를 초래합니다. 동기화된 메소드는 매우 느리며 성능을 저하시킵니다. 따라서 Java에서 동기화를 사용할 때는 반드시 필요한 경우에 그리고 사용하더라도 동기화가 필요한 핵심적인 영역에 대한 synchronized 블록을 고려해야 합니다.
  10. 원하는 코드의 핵심적인 영역만 잠그고 성능을 저하시킬 수 있는 메소드 전체 잠금을 피하는 Java synchronized 블록이 synchronized 메소드보다 좋은 방법입니다. 이 개념과 관련한 Java 동기화의 좋은 예가 앞에서 봤던 Singleton 클래스의 getInstance() 메소드의 예입니다.
  11. 정적 synchronized 메소드와 비정적 synchronized 메소드 모두 서로 다른 객체를 잠그기 때문에 동시에 실행할 가능성이 있습니다.
  12. Java synchronized 코드는 동기화가 잘못 구현되었을 경우, 멀티 스레드가 접근할 때 교착 상태 혹은 기아 상태를 유발할 수 있습니다. 어떻게 교착 상태를 피할 수 있는지는 여기 기술된 내용들을 잘 숙지하세요.
  13. JLS(Java Language Specification)에 따르면 synchronized 키워드를 생성자에 함께 사용할 수 없습니다. 사용할 경우 사용 자체가 잘못된 것이며 에러를 유발할 수 있습니다. 논리적으로 본다면 다른 스레드에서 해당 스레드가 객체생성을 끝낼 때까지 생성된 객체를 볼 수 없기 때문에 생성자에 synchronized 키워드를 사용할 수 없습니다.
  14. Java의 변수에 synchronized 키워드를 사용할 수 없으며 메소드에 volatile 키워드를 사용할 수 없습니다.
  15. 좀더 복잡한 프로그램을 작성하기 위해 Java.util.concurrent.locks 패키지는 synchronized 키워드에 의해 제공되는 기능을 확장합니다. Reentrancy 그리고 interruptible locks와 같은 더 많은 기능을 제공합니다.
  16. Java synchronized 키워드는 메모리 역시 동기화합니다.
  17. Java에서 동기화와 관련된 중요한 메소드들은 Object 클래스에 정의되어 있는 wait(), notify() 그리고 notifyAll()입니다.
  18. synchronized 블록 내에서 final이 아닌 필드를 동기화해서는 안됩니다. final이 아닌 필드의 참조는 언제든지 바뀔 수 있으며 그런 후 다른 스레드는 다른 객체를 동기화하게 됩니다. 즉, 동기화가 되지 않습니다.
  19. synchronized 블록에서 잠금으로 String 객체를 사용하지 않을 것을 권합니다. String은 immutable 객체며 literal string과 interned string은 String pool에 저장됩니다. 따라서 만일 코드의 다른 부분이나 서드 파티 라이브러리가 같은 문자열을 잠금으로 사용한다면 서로 상관 없음에도 불구하고 모두 같은 객체를 잠기게 되어 결과적으로 이상 현상이 발생하거나 혹은 성능이 저하의 원인이 될 수 있습니다. 동기화를 위해 String 객체 대신 Java synchronized 블록에 새로운 Object()를 사용할 것을 권장합니다.
  20. Calendar와 SimpleDataFormat 같은 Java 라이브러리 클래스들은 다중 스레드 환경에서 안전하지 않으며 다중 스레드 환경에서 사용되기 위해서는 부수적인 동기화가 필요합니다.
  
  
문제 13. C++과 Java에서 빈 클래스의 크기는 어떻게 됩니까?
- 각 객체는 유일한 주소를 가지기 때문에(표준에 정의된 것을 포함하여) 객체의 크기가 실제 0일 수 없습니다.
- 배열의 사이즈가 0인 객체를 생각해 봅시다. 배열의 사이즈가 0이기 때문에 이들을 나열하면 모두 같은 주소에 위치합니다.
- 따라서 객체 크기가 0을 가질 수 없다고 말하는 게 더 쉬울 것입니다.
- 객체의 크기가 0일 수 없다 하더라도 실제 공간을 차지하지 않으면 파생된 클래스의 크기도 증가하지 않습니다.
  

문제 14. C와 C++에서 i++ + i++의 값은 무엇입니까?
- 정해져 있지 않습니다. 기본적으로 C와 C++에서 변수의 값을 쓰는 식을 두 번 읽을 경우, 결과는 확실하지 않습니다. 이렇게 해서는 안됩니다.
- 또 다른 예가 v[i] = i++; 그리고 f(v[i], i++);와 같은 구문입니다.
- 결과가 정해져 있지 않은 이유는 함수 인수의 값을 구하는 순서가 정해지지 않았기 때문입니다.
  
  
  
  
  
## Chapter 02. INTRODUCTION

## Chapter 03. 재귀와 역추적

## Chapter 04. 연결 리스트

## Chapter 05. 스택

## Chapter 06. 큐

## Chapter 07. 트리

## Chapter 08. 우선 순위 큐와 힙

## Chapter 09. 그래프 알고리즘

## Chapter 10. 정렬

## Chapter 11. 검색

## Chapter 12. 선택 알고리즘

## Chapter 13. 심볼 테이블

## Chapter 14. 해싱

## Chapter 15. 문자열 알고리즘

## Chapter 16. 알고리즘 디자인 기술

## Chapter 17. 탐욕 알고리즘

## Chapter 18. 분할 정복 알고리즘

## Chapter 19. 동적 계획법

## Chapter 20. 복잡도 클래스

## Chapter 21. 디자인(설계) 인터뷰 질문들

## Chapter 22. 운영체제 시스템 개념

## Chapter 23. 컴퓨터 네트워크 기본

## Chapter 24. 데이터베이스 개념

## Chapter 25. 대답하기 어려운 문제들

## Chapter 26. 기술 이외의 조언

## Chapter 27. 그밖의 개념들


